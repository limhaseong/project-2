-- ■■■ 테이블 생성 & COMMENTS ■■■---------------------------------------------------

--[과목 테이블 생성]
CREATE TABLE SUBJECTS
( SUB_CODE VARCHAR2(20) 
, SUB_NAME VARCHAR2(30)  CONSTRAINT SUB_NAME_NN NOT NULL
, CONSTRAINT SUBJECTS_SUB_CODE_PK PRIMARY KEY(SUB_CODE)
);


--[강의실 테이블 생성]
CREATE TABLE CLASSROOMS
( ROOM_CODE         VARCHAR2(20)
, ROOM_NAME         VARCHAR2(20)  CONSTRAINT CLASSROOMS_NAME_NN NOT NULL
, ROOM_EXPLANATION  VARCHAR2(100)
, CONSTRAINT CLASSROOMS_CODE_PK PRIMARY KEY(ROOM_CODE)
);


--[과정 테이블 생성]
CREATE TABLE COURSES
( CRS_CODE  VARCHAR2(20)    
, CRS_NAME  VARCHAR2(100)    CONSTRAINT CRS_NAME_NN NOT NULL
, CONSTRAINT COURSES_CRS_CODE_PK PRIMARY KEY(CRS_CODE)
);


--[교재 테이블 생성]
CREATE TABLE BOOKS
( BK_CODE           VARCHAR2(20)
, BK_NAME           VARCHAR2(100)    CONSTRAINT BOOKS_BK_NAME_NN NOT NULL
, BK_PRICE          NUMBER(6)        CONSTRAINT BOOKS_BK_PRICE_NN NOT NULL
, BK_EXPLANATION    VARCHAR2(100)
, CONSTRAINT BOOKS_BK_CODE_PK PRIMARY KEY(BK_CODE)
);


--[중도탈락사유 테이블 생성]
CREATE TABLE DROP_REASONS
( DO_REASON_CODE           VARCHAR2(20)
, DO_REASON                VARCHAR2(50)     CONSTRAINT REASONS_DO_REASON_NN NOT NULL
, CONSTRAINT REASON_DO_REASON_CODE_PK PRIMARY KEY(DO_REASON_CODE)
);


--[교수 테이블 생성]
CREATE TABLE PROFESSORS
( PF_CODE   VARCHAR2(20)    
, PF_ID     VARCHAR2(20)    CONSTRAINT PF_ID_NN NOT NULL
, PF_PW     VARCHAR2(20)    CONSTRAINT PF_PW_NN NOT NULL
, PF_NAME   VARCHAR2(20)    CONSTRAINT PF_NAME_NN NOT NULL
, PF_SSN    VARCHAR(14)     CONSTRAINT PF_SSN_NN NOT NULL
, PF_DATE   DATE            DEFAULT SYSDATE
, CONSTRAINT PROFESSORS_PF_CODE_PK PRIMARY KEY(PF_CODE)
, CONSTRAINT PROFESSORS_PF_ID_UK UNIQUE(PF_ID)
, CONSTRAINT PROFESSORS_PF_PW_UK CHECK (LENGTH(PF_PW) >= 7 AND LENGTH(PF_PW) <= 20)
);


--[관리자 테이블 생성]
CREATE TABLE ADMINS
( AD_CODE   VARCHAR2(20)    
, AD_ID     VARCHAR2(20)    CONSTRAINT AD_ID_NN NOT NULL
, AD_PW     VARCHAR2(20)    CONSTRAINT AD_PW_NN NOT NULL
, AD_DATE   DATE            DEFAULT SYSDATE
, CONSTRAINT ADMINS_AD_CODE_PK PRIMARY KEY(AD_CODE)
, CONSTRAINT ADMINS_AD_ID_UK   UNIQUE(AD_ID)
, CONSTRAINT ADMINS_AD_PW_UK CHECK (LENGTH(AD_PW) >= 7 AND LENGTH(AD_PW) <= 20) 
);


--[학생 테이블 생성]
CREATE TABLE STUDENTS
( ST_CODE  VARCHAR2(20)
, ST_ID    VARCHAR2(20) CONSTRAINT ST_ID_NN NOT NULL
, ST_PW    VARCHAR2(20) CONSTRAINT ST_PW_NN NOT NULL
, ST_NAME  VARCHAR2(20) CONSTRAINT ST_NAME_NN NOT NULL
, ST_SSN   VARCHAR(14)  CONSTRAINT ST_SSN_NN NOT NULL
, ST_DATE  DATE         DEFAULT SYSDATE
, CONSTRAINT STUDENTS_ST_CODE_PK PRIMARY KEY(ST_CODE)
, CONSTRAINT STUDENTS_ST_ID_UK  UNIQUE(ST_ID)
, CONSTRAINT STUDENTS_ST_PW_CK CHECK (LENGTH(ST_PW) >= 7 AND LENGTH(ST_PW) <= 20)
);


--[개설과정 테이블생성]
CREATE TABLE OPEN_COURSES
( OCRS_CODE         VARCHAR2(20)
, CRS_CODE          VARCHAR2(20)
, PF_CODE             VARCHAR2(20)
, ROOM_CODE         VARCHAR2(20)
, START_DATE        DATE    CONSTRAINT COURSES_START_DATE_NN NOT NULL
, END_DATE          DATE    CONSTRAINT COURSES_END_DATE_NN NOT NULL
, CONSTRAINT OCRS_OCRS_CODE_PK PRIMARY KEY(OCRS_CODE)
, CONSTRAINT OCRS_CRS_CODE_FK FOREIGN KEY(CRS_CODE) REFERENCES COURSES(CRS_CODE)
, CONSTRAINT OCRS_PF_ID_FK FOREIGN KEY(PF_CODE) REFERENCES PROFESSORS(PF_CODE)
, CONSTRAINT OCRS_ROOM_CODE_FK FOREIGN KEY(ROOM_CODE) REFERENCES CLASSROOMS(ROOM_CODE)
);


--[수강신청 테이블생성]
CREATE TABLE COURSE_REGISTRATIONS
( REG_CODE          VARCHAR2(20)
, ST_CODE           VARCHAR2(20)
, OCRS_CODE         VARCHAR2(20)
, REG_DATE          DATE        DEFAULT SYSDATE
, CONSTRAINT COURSE_REG_REG_CODE_PK PRIMARY KEY(REG_CODE)

, CONSTRAINT COURSE_REG_ST_CODE_FK  FOREIGN KEY(ST_CODE)
        REFERENCES STUDENTS(ST_CODE)
        
, CONSTRAINT COURSE_REG_OCRS_CODE_FK  FOREIGN KEY(OCRS_CODE)
        REFERENCES OPEN_COURSES(OCRS_CODE)
);


--[중도탈락 테이블생성]
CREATE TABLE DROP_OUT_LISTS
( DO_CODE           VARCHAR2(20)   
, REG_CODE          VARCHAR2(20) 
, DO_REASON_CODE    VARCHAR2(20) 
, DO_DATE           DATE DEFAULT SYSDATE
, CONSTRAINT DO_LISTS_DO_CODE_PK PRIMARY KEY(DO_CODE)
, CONSTRAINT DO_LISTS_REG_CODE_FK FOREIGN KEY(REG_CODE)
                REFERENCES COURSE_REGISTRATIONS(REG_CODE)
, CONSTRAINT DO_LISTS_DO_REASON_CODE_FK FOREIGN KEY(DO_REASON_CODE)
                REFERENCES DROP_REASONS(DO_REASON_CODE)
);


--[개설과목 테이블생성]
CREATE TABLE OPEN_SUBJECTS
( OSUB_CODE             VARCHAR(20)
, OCRS_CODE             VARCHAR(20)
, SUB_CODE              VARCHAR(20) 
, BK_CODE               VARCHAR(20)
, SUB_START_DATE        DATE        CONSTRAINT OPEN_SUBJECTS_SSD_NN NOT NULL
, SUB_END_DATE          DATE        CONSTRAINT OPEN_SUBJECTS_SED_NN NOT NULL
, ATTENDANCE_SCORE      NUMBER(3)   CONSTRAINT OPEN_SUBJECTS_AS_NN NOT NULL
, WRITTEN_SCORE         NUMBER(3)   CONSTRAINT OPEN_SUBJECTS_WS_NN NOT NULL
, PRACTICAL_SCORE       NUMBER(3)   CONSTRAINT OPEN_SUBJECTS_PS_NN NOT NULL
, CONSTRAINT OPEN_SUBJECTS_OSUB_CODE_PK PRIMARY KEY(OSUB_CODE)
, CONSTRAINT ATTENDANCE_SCORE CHECK(ATTENDANCE_SCORE BETWEEN 0 AND 100)
, CONSTRAINT WRITTEN_SCORE CHECK(WRITTEN_SCORE BETWEEN 0 AND 100)
, CONSTRAINT PRACTICAL_SCORE CHECK(PRACTICAL_SCORE BETWEEN 0 AND 100)
, CONSTRAINT OCRS_CODE_FK FOREIGN KEY(OCRS_CODE) REFERENCES OPEN_COURSES(OCRS_CODE)
, CONSTRAINT SUB_CODE_FK FOREIGN KEY(SUB_CODE) REFERENCES SUBJECTS(SUB_CODE)
, CONSTRAINT BK_CODE_FK FOREIGN KEY(BK_CODE) REFERENCES BOOKS(BK_CODE)
);

-- 출결/필기/실기 점수 기본값 30/30/40 설정 → 기본값으로 들어가고 교수가 UPDATE로 변경 가능하도록 구성
ALTER TABLE OPEN_SUBJECTS
MODIFY ATTENDANCE_SCORE DEFAULT 30;
ALTER TABLE OPEN_SUBJECTS
MODIFY WRITTEN_SCORE DEFAULT 30;
ALTER TABLE OPEN_SUBJECTS
MODIFY PRACTICAL_SCORE DEFAULT 40;



--[성적 테이블 생성]
CREATE TABLE SCORES
( SCORE_CODE            VARCHAR2(20)
, REG_CODE              VARCHAR2(20)
, OSUB_CODE             VARCHAR2(20)
, ATTENDANCE_SCORE      NUMBER(3)   CONSTRAINT ATTENDANCE_SCORE_NN NOT NULL
, WRITTEN_SCORE         NUMBER(3)   CONSTRAINT WRITTEN_SCORE_NN NOT NULL
, PRACTICAL_SCORE       NUMBER(3)   CONSTRAINT PRACTICAL_SCORE_NN NOT NULL
, TEST_DATE             DATE        CONSTRAINT TEST_DATE_NN NOT NULL
, CONSTRAINT SCORES_SCORE_CODE_PK PRIMARY KEY(SCORE_CODE)
, CONSTRAINT SCORES_REG_CODE_FK FOREIGN KEY(REG_CODE)
             REFERENCES COURSE_REGISTRATIONS(REG_CODE)
, CONSTRAINT SCORES_OSUB_CODE_FK FOREIGN KEY(OSUB_CODE)
             REFERENCES OPEN_SUBJECTS(OSUB_CODE)
, CONSTRAINT SCORES_ATTENDANCE_SCORE_CK CHECK (ATTENDANCE_SCORE BETWEEN 0 AND 100)
, CONSTRAINT SCORES_WRITTEN_SCORE_CK CHECK (WRITTEN_SCORE BETWEEN 0 AND 100)
, CONSTRAINT SCORES_PRACTICAL_SCORE_CK CHECK (PRACTICAL_SCORE BETWEEN 0 AND 100)
);



-- ■■■ 테이블 COMMENTS 작성 ■■■-------------------------------------------

COMMENT ON TABLE SUBJECTS IS '과목 정보';
COMMENT ON COLUMN SUBJECTS.SUB_CODE IS '과목 코드';
COMMENT ON COLUMN SUBJECTS.SUB_NAME IS '과목명';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'SUBJECTS';

COMMENT ON TABLE COURSES IS '과정 정보';
COMMENT ON COLUMN COURSES.CRS_CODE IS '과정 코드';
COMMENT ON COLUMN COURSES.CRS_NAME IS '과정명';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'COURSES';

COMMENT ON TABLE ADMINS IS '관리자 정보';
COMMENT ON COLUMN ADMINS.AD_CODE IS '관리자 코드';
COMMENT ON COLUMN ADMINS.AD_ID IS '관리자ID';
COMMENT ON COLUMN ADMINS.AD_PW IS '관리자PW';
COMMENT ON COLUMN ADMINS.AD_DATE IS '등록일';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'ADMINS';

COMMENT ON TABLE PROFESSORS IS '교수 정보';
COMMENT ON COLUMN PROFESSORS.PF_CODE IS '교수 코드';
COMMENT ON COLUMN PROFESSORS.PF_ID IS '교수ID';
COMMENT ON COLUMN PROFESSORS.PF_PW IS '교수PW';
COMMENT ON COLUMN PROFESSORS.PF_NAME IS '교수명';
COMMENT ON COLUMN PROFESSORS.PF_SSN IS '주민등록번호';
COMMENT ON COLUMN PROFESSORS.PF_DATE IS '등록일';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'PROFESSORS';

COMMENT ON TABLE OPEN_COURSES IS '개설과정 정보';
COMMENT ON COLUMN OPEN_COURSES.OCRS_CODE IS '개설과정 코드';
COMMENT ON COLUMN OPEN_COURSES.START_DATE IS '과정 시작일';
COMMENT ON COLUMN OPEN_COURSES.END_DATE IS '과정 종료일';
COMMENT ON COLUMN OPEN_COURSES.CRS_CODE IS '과정 코드';
COMMENT ON COLUMN OPEN_COURSES.PF_CODE IS '교수 코드';
COMMENT ON COLUMN OPEN_COURSES.ROOM_CODE IS '강의실 코드';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'OPEN_COURSES';

COMMENT ON TABLE OPEN_SUBJECTS IS '개설과목 정보';
COMMENT ON COLUMN OPEN_SUBJECTS.OCRS_CODE IS '개설과정 코드';
COMMENT ON COLUMN OPEN_SUBJECTS.OSUB_CODE IS '개설과목 코드';
COMMENT ON COLUMN OPEN_SUBJECTS.SUB_CODE IS '과목 코드';
COMMENT ON COLUMN OPEN_SUBJECTS.BK_CODE IS '교재 코드';
COMMENT ON COLUMN OPEN_SUBJECTS.SUB_START_DATE IS '과목 시작일';
COMMENT ON COLUMN OPEN_SUBJECTS.SUB_END_DATE IS '과목 종료일';
COMMENT ON COLUMN OPEN_SUBJECTS.ATTENDANCE_SCORE IS '출결 배점';
COMMENT ON COLUMN OPEN_SUBJECTS.WRITTEN_SCORE IS '필기 배점';
COMMENT ON COLUMN OPEN_SUBJECTS.PRACTICAL_SCORE IS '실기 배점';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'OPEN_SUBJECTS';

COMMENT ON TABLE BOOKS IS '교재 정보';
COMMENT ON COLUMN BOOKS.BK_CODE IS '교재 코드';
COMMENT ON COLUMN BOOKS.BK_NAME IS '교재명';
COMMENT ON COLUMN BOOKS.BK_PRICE IS '교재 가격';
COMMENT ON COLUMN BOOKS.BK_EXPLANATION IS '교재 설명';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'BOOKS';

COMMENT ON TABLE STUDENTS IS '학생 정보';
COMMENT ON COLUMN STUDENTS.ST_CODE IS '학생 코드';
COMMENT ON COLUMN STUDENTS.ST_ID IS '학생 ID';
COMMENT ON COLUMN STUDENTS.ST_PW IS '학생 PW';
COMMENT ON COLUMN STUDENTS.ST_NAME IS '학생 이름';
COMMENT ON COLUMN STUDENTS.ST_SSN IS '주민등록번호';
COMMENT ON COLUMN STUDENTS.ST_DATE IS '등록일';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'STUDENTS';

COMMENT ON TABLE COURSE_REGISTRATIONS IS '수강신청 정보';
COMMENT ON COLUMN COURSE_REGISTRATIONS.REG_CODE IS '수강신청 코드';
COMMENT ON COLUMN COURSE_REGISTRATIONS.ST_CODE IS '학생 코드';
COMMENT ON COLUMN COURSE_REGISTRATIONS.OCRS_CODE IS '개설과정 코드';
COMMENT ON COLUMN COURSE_REGISTRATIONS.REG_DATE IS '수강신청일';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'COURSE_REGISTRATIONS';

COMMENT ON TABLE CLASSROOMS IS '강의실 정보';
COMMENT ON COLUMN CLASSROOMS.ROOM_CODE IS '강의실 코드';
COMMENT ON COLUMN CLASSROOMS.ROOM_NAME IS '강의실명';
COMMENT ON COLUMN CLASSROOMS.ROOM_EXPLANATION IS '강의실 설명';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'CLASSROOMS';

COMMENT ON TABLE DROP_REASONS IS '중도탈락 사유 정보';
COMMENT ON COLUMN DROP_REASONS.DO_REASON_CODE IS '중도탈락사유 코드';
COMMENT ON COLUMN DROP_REASONS.DO_REASON IS '중도탈락 사유';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'DROP_REASONS';

COMMENT ON TABLE DROP_OUT_LISTS IS '중도탈락 정보';
COMMENT ON COLUMN DROP_OUT_LISTS.DO_CODE IS '중도탈락 코드';
COMMENT ON COLUMN DROP_OUT_LISTS.REG_CODE IS '수강신청 코드';
COMMENT ON COLUMN DROP_OUT_LISTS.DO_REASON_CODE IS '중도탈락사유 코드';
COMMENT ON COLUMN DROP_OUT_LISTS.DO_DATE IS '중도탈락일';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'DROP_OUT_LISTS';

COMMENT ON TABLE SCORES IS '성적 정보';
COMMENT ON COLUMN SCORES.SCORE_CODE IS '성적 코드';
COMMENT ON COLUMN SCORES.REG_CODE IS '수강신청 코드';
COMMENT ON COLUMN SCORES.OSUB_CODE IS '개설과목 코드';
COMMENT ON COLUMN SCORES.ATTENDANCE_SCORE IS '출결 점수';
COMMENT ON COLUMN SCORES.WRITTEN_SCORE IS '필기 점수';
COMMENT ON COLUMN SCORES.PRACTICAL_SCORE IS '실기 점수';
COMMENT ON COLUMN SCORES.TEST_DATE IS '시험일';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'SCORES';

--■■■ PL/SQL 문 ■■■-------------------------------------------------------

--★ 0. 기초 작업 → 요구분석서에는 없지만 필요한 데이터 넣어주기

--■ 관리자 데이터
-- 관리자 데이터 시퀀스 생성
CREATE SEQUENCE ADMINS_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;

-- 관리자 데이터 INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_ADMINS_INSERT
( V_AD_ID       IN ADMINS.AD_ID%TYPE
, V_AD_PW       IN ADMINS.AD_PW%TYPE
)
IS
    COUNT_NUM         NUMBER(2);
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    
    SELECT COUNT(*) INTO COUNT_NUM
    FROM ADMINS
    WHERE AD_ID = V_AD_ID;
    
    IF (COUNT_NUM = 1)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    -- 데이터 입력 쿼리문 구성
    INSERT INTO ADMINS(AD_CODE, AD_ID, AD_PW, AD_DATE)
    VALUES(('AD' || LPAD(TO_CHAR(ADMINS_SEQ.NEXTVAL), 3, '0')), V_AD_ID, V_AD_PW, SYSDATE);   
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20001, '이미 등록된 ID입니다.');
            ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
    
    --커밋
    --COMMIT;
END;

-- ◎ 관리자 데이터 입력
EXEC PRC_ADMINS_INSERT('HYEIN', 'java001');
EXEC PRC_ADMINS_INSERT('MINJI', 'java002');
EXEC PRC_ADMINS_INSERT('JUHYUNG', 'java003');
EXEC PRC_ADMINS_INSERT('DONGMIN', 'java004');
EXEC PRC_ADMINS_INSERT('HASEONG', 'java005');
EXEC PRC_ADMINS_INSERT('HANUL', 'java006');

SELECT *
FROM ADMINS;


--■ 교재 데이터
-- 교재 데이터 시퀀스 생성
CREATE SEQUENCE BOOKS_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;

-- 교재 데이터 INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_BOOKS_INSERT
( V_BK_NAME  IN BOOKS.BK_NAME%TYPE
,  V_BK_PRICE  IN BOOKS.BK_PRICE%TYPE
,  V_BK_EXPLANATION  IN BOOKS.BK_EXPLANATION%TYPE
 
)    
IS
 V_BK_CODE      BOOKS.BK_CODE%TYPE;
 V_BK_BOOKNAME  BOOKS.BK_NAME%TYPE;
BEGIN

    INSERT INTO BOOKS(BK_CODE , BK_NAME, BK_PRICE , BK_EXPLANATION)
    VALUES(('BK' || LPAD(TO_CHAR(BOOKS_SEQ.NEXTVAL), 3, '0')), V_BK_NAME, V_BK_PRICE, V_BK_EXPLANATION);
   
   -- COMMIT;
END;

-- ◎ 교재 데이터 입력   
EXEC PRC_BOOKS_INSERT('Do it! 점프 투 파이썬', '19800', '중학생도 첫날부터 실습하는 초고속 입문서')
EXEC PRC_BOOKS_INSERT('AWS 교과서', '34200', '개념 설명과 실습 예제로 실속 있게 구성한 AWS 입문서!')
EXEC PRC_BOOKS_INSERT('실전 스프링 부트', '36000', '기본 개념부터 실무 베스트 프랙티스, 그리고 GraalVM, GraphQL, R소켓')
EXEC PRC_BOOKS_INSERT('문제 해결을 위한 알고리즘 with 수학', '37800', '알고리즘 문제 해결에 꼭 필요한 수학적 지식과 사고력')
EXEC PRC_BOOKS_INSERT('오라클의 정석', '27000', '한 권으로 끝내는 오라클 기본 교과서')
EXEC PRC_BOOKS_INSERT('이것이 취업을 위한 코딩 테스트다 with 자바', '30600', '취업과 이직을 결정하는 알고리즘 인터뷰 완벽')
EXEC PRC_BOOKS_INSERT('쿠버네티스 교과서', '39600', '기초부터 운영까지, 실전에 강한 쿠버네티스 사용법!')
EXEC PRC_BOOKS_INSERT('Must Have 성낙현의 JSP 자바 웹 프로그래밍', '27000', ' JSP·서블릿 기초부터 탄탄하게')
EXEC PRC_BOOKS_INSERT('예제로 배우는 자바스크립트', '25200', '단계별 300제로 정복하는 자바스크립트')
EXEC PRC_BOOKS_INSERT('완성된 웹사이트로 배우는 HTML와 CSS 웹 디자인', '19800', '5개 예제로 배우는 효율적인 웹사이트 제작 노하우')
EXEC PRC_BOOKS_INSERT('C++ 소프트웨어 디자인', '28800', '고품질 소프트웨어 구축을 위한 설계 원칙과 패턴')
EXEC PRC_BOOKS_INSERT('스프링 프레임워크 첫걸음', '22500', '그림과 실습으로 쉽게 배우는 스프링 프레임워크 완벽 입문서')

SELECT *
FROM BOOKS;


--■ 중도탈락사유 데이터
-- 중도탈락사유 시퀀스 생성
CREATE SEQUENCE DO_REASONS_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;


-- 중도탈락사유 입력 프로시저
CREATE OR REPLACE PROCEDURE PRC_DROP_REASONS
(V_REASON   IN DROP_REASONS.DO_REASON%TYPE   
)
IS
        COUNT_NUM NUMBER;
        USER_DEFINE_ERROR EXCEPTION;
BEGIN
        SELECT COUNT(DO_REASON) INTO COUNT_NUM
        FROM DROP_REASONS
        WHERE DO_REASON = V_REASON;

        IF COUNT_NUM = 1
           THEN RAISE USER_DEFINE_ERROR; 
        END IF;
            
        INSERT INTO DROP_REASONS(DO_REASON_CODE , DO_REASON)
        VALUES('DR' || LPAD(TO_CHAR(DO_REASONS_SEQ.NEXTVAL),3,'0') , V_REASON);
        
        EXCEPTION 
            WHEN USER_DEFINE_ERROR
                 THEN RAISE_APPLICATION_ERROR(-20004,'이미 존재하는 사유입니다.');
                 ROLLBACK;
            WHEN OTHERS
                 THEN ROLLBACK;
        -- 커밋
        --COMMIT;    
END;

-- ◎ 중도탈락 데이터 입력   
EXEC PRC_DROP_REASONS('퇴학')
EXEC PRC_DROP_REASONS('부적응')
EXEC PRC_DROP_REASONS('해외출국')
EXEC PRC_DROP_REASONS('군 입대')
EXEC PRC_DROP_REASONS('질병')

SELECT *
FROM DROP_REASONS;


-- ■ 강의실 데이터
-- 강의실 데이터 시퀀스 생성
CREATE SEQUENCE CLASSROOMS_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;

-- 강의실 데이터 입력 프로시저
CREATE OR REPLACE PROCEDURE PRC_CLASSROOMS_INSERT
(V_ROOM_NAME   IN  CLASSROOMS.ROOM_NAME%TYPE
,V_ROOM_EXP    IN  CLASSROOMS.ROOM_EXPLANATION%TYPE
)
IS 
        USER_DEFINE_ERROR EXCEPTION;
        COUNT_NUM NUMBER;
BEGIN
        SELECT COUNT(ROOM_NAME) INTO COUNT_NUM
        FROM CLASSROOMS
        WHERE ROOM_NAME = V_ROOM_NAME;
        
        IF COUNT_NUM = 1
            THEN RAISE USER_DEFINE_ERROR;
        END IF;
        
        INSERT INTO CLASSROOMS(ROOM_CODE , ROOM_NAME, ROOM_EXPLANATION)
        VALUES ('CR' || LPAD(TO_CHAR(CLASSROOMS_SEQ.NEXTVAL),3,'0'),V_ROOM_NAME, V_ROOM_EXP);
        
        EXCEPTION
            WHEN USER_DEFINE_ERROR
                THEN RAISE_APPLICATION_ERROR(-20005,'이미 등록된 강의실입니다.');
                ROLLBACK;
            WHEN OTHERS
                THEN ROLLBACK;
        -- 커밋
        --COMMIT;
END;

-- ◎ 강의실 데이터 입력   
EXEC PRC_CLASSROOMS_INSERT('A반','1층 101호 최대 수용 인원 : 25명');
EXEC PRC_CLASSROOMS_INSERT('B반','1층 102호 최대 수용 인원 : 30명');
EXEC PRC_CLASSROOMS_INSERT('C반','2층 201호 최대 수용 인원 : 25명');
EXEC PRC_CLASSROOMS_INSERT('D반','2층 202호 최대 수용 인원 : 30명');
EXEC PRC_CLASSROOMS_INSERT('E반','3층 301호 최대 수용 인원 : 25명');
EXEC PRC_CLASSROOMS_INSERT('F반','3층 302호 최대 수용 인원 : 30명');
EXEC PRC_CLASSROOMS_INSERT('G반','4층 401호 최대 수용 인원 : 25명');
EXEC PRC_CLASSROOMS_INSERT('H반','4층 402호 최대 수용 인원 : 30명');

SELECT *
FROM CLASSROOMS;


---------------------------------------------------------------------------------------------------------------------------------------

-----------------------[ 요구 분석서 기반 테스트 ]---------------------------------------------------
--★ 관리자 측 요구분석

--2. 관리자 계정 관련 기능 구현
--1) 관리자는 시스템의 모든 기능을 로그인 과정을 거친 후에 사용할 수 있어야 한다.
--   모든 기능에는 교수자 계정 관리, 과정 관리, 과목 관리, 학생 관리, 성적 관리를 포함한다.
-- → 관리자 로그인
CREATE OR REPLACE PROCEDURE PR_ADMIN_LOGIN
( V_AD_ID   ADMINS.AD_ID%TYPE
, V_AD_PW   ADMINS.AD_PW%TYPE
)
IS
    AD_ID_TEMP      ADMINS.AD_ID%TYPE;
    AD_PW_TEMP      ADMINS.AD_PW%TYPE;
    COUNT_NUM       NUMBER(2);
    USER_DEFINE_ERROR1  EXCEPTION;
    USER_DEFINE_ERROR2  EXCEPTION;
BEGIN

    SELECT COUNT(*) INTO COUNT_NUM
    FROM ADMINS
    WHERE AD_ID = V_AD_ID;
    
    IF (COUNT_NUM != 1)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    SELECT AD_ID, AD_PW INTO AD_ID_TEMP, AD_PW_TEMP
    FROM ADMINS
    WHERE AD_ID = V_AD_ID;    
        
    IF (AD_PW_TEMP != V_AD_PW)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;     
    
    DBMS_OUTPUT.PUT_LINE('관리자 ' || V_AD_ID || '님으로 로그인되었습니다.');
      
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20001, '관리자 아이디가 일치하지 않습니다.');
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20002, '관리자 비밀번호가 일치하지 않습니다.');   
END;


--3. 교수자 계정 관리 기능 구현
--1) 관리자는 여러 명의 교수자를 사전에 등록할 수 있어야 한다.
--   입력 정보는 교수자 이름, 주민등록번호 뒷자리를 기본으로 등록하고,
--   주민등록번호 뒷자리는 교수자 본인이 로그인 시 패스워드로 사용되도록 한다.

-- 교수 데이터 시퀀스 생성
CREATE SEQUENCE PROFESSORS_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;

-- 숫자 판별 함수 생성
CREATE OR REPLACE FUNCTION IS_NUMBER(STR VARCHAR2) RETURN NUMBER
IS
   V_RET NUMBER;
BEGIN
   IF STR IS NULL OR LENGTH(TRIM(STR)) = 0 THEN

      RETURN 0;

   END IF;
   
   V_RET := TO_NUMBER(STR);

   RETURN 1;
   
   EXCEPTION WHEN OTHERS
        THEN RETURN 0;

END;

-- 교수 데이터 입력 프로시저
CREATE OR REPLACE PROCEDURE PRC_PROFESSORS_INSERT
( V_PF_ID       IN PROFESSORS.PF_ID%TYPE
, V_PF_NAME     IN PROFESSORS.PF_NAME%TYPE
, V_PF_SSN      IN PROFESSORS.PF_SSN%TYPE
)
IS
    V_PF_ID2 PROFESSORS.PF_ID%TYPE;
    V_FLAG NUMBER := 0;
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    SELECT COUNT(*) INTO V_FLAG
    FROM PROFESSORS
    WHERE PF_ID = V_PF_ID;

    IF V_FLAG = 1
        THEN RAISE_APPLICATION_ERROR(-20050, '이미 등록된 ID입니다.' );
        ROLLBACK;
    END IF;
    
    IF IS_NUMBER(SUBSTR(V_PF_SSN,1,6)) = 0
        THEN RAISE_APPLICATION_ERROR(-20044, '숫자만 입력 가능합니다.' );
        ROLLBACK;
    ELSIF IS_NUMBER(SUBSTR(V_PF_SSN,8,14)) = 0
        THEN RAISE_APPLICATION_ERROR(-20044, '숫자만 입력 가능합니다.' );
        ROLLBACK;
    END IF;
    
    -- 데이터 입력 쿼리문 구성
    INSERT INTO PROFESSORS(PF_CODE, PF_ID, PF_PW, PF_NAME, PF_SSN)
    VALUES(('PF' || LPAD(TO_CHAR(PROFESSORS_SEQ.NEXTVAL+8), 3, '0')), V_PF_ID, SUBSTR(V_PF_SSN, 8, 7), V_PF_NAME, V_PF_SSN);

    --커밋
    --COMMIT;
END;

-- ◎ 교수 데이터 입력
EXEC PRC_PROFESSORS_INSERT('MANGGOM', '망곰이', '781110-1684233');
EXEC PRC_PROFESSORS_INSERT('PEACH', '어피치', '670621-2491530');
EXEC PRC_PROFESSORS_INSERT('CHUNSIK', '춘식이', '830213-1125762');
EXEC PRC_PROFESSORS_INSERT('RYAN', '라이언', '730230-1254873');
EXEC PRC_PROFESSORS_INSERT('JAYJ', '제이지', '690324-1456324');
EXEC PRC_PROFESSORS_INSERT('CHU', '피카츄', '810903-2678431');
EXEC PRC_PROFESSORS_INSERT('DANG', '당소소', '880129-2348154');

SELECT *
FROM PROFESSORS;

--2) 관리자는 등록된 모든 교수자의 정보를 출력하여 볼 수 있어야 한다.
--   출력 정보는 교수자 명, 배정된 과목명, 과목 기간(시작, 종료), 교재 명, 강의실, 강의 진행 여부를 출력한다.
-- VIEW 생성
CREATE OR REPLACE VIEW VIEW_PROFESSORS
AS
SELECT B.PF_NAME "교수자명", F.SUB_NAME "배정된 과목명", A.SUB_START_DATE "시작일", A.SUB_END_DATE "종료일", D.BK_NAME "교재명", E.ROOM_NAME "강의실"
    , CASE WHEN SYSDATE > A.SUB_END_DATE THEN '강의종료'
         WHEN SYSDATE < A.SUB_START_DATE THEN '강의예정'
         WHEN SYSDATE > A.SUB_START_DATE AND SYSDATE < A.SUB_END_DATE THEN '강의중' ELSE '강의없음' END "강의진행여부"
FROM OPEN_SUBJECTS A, PROFESSORS B, OPEN_COURSES C, BOOKS D, CLASSROOMS E, SUBJECTS F
WHERE B.PF_CODE = C.PF_CODE
AND C.OCRS_CODE = A.OCRS_CODE
AND F.SUB_CODE = A.SUB_CODE
AND A.BK_CODE = D.BK_CODE
AND C.ROOM_CODE = E.ROOM_CODE;

--◎ VIEW 조회
SELECT *
FROM VIEW_PROFESSORS;

--3) 관리자는 입력된 교수자 정보에 대하여 ①수정, ②삭제 할 수 있어야 한다.

--① 교수 데이터 수정 프로시저 
--교수 수정
CREATE OR REPLACE PROCEDURE PRC_PROFESSORS_UPDATE
( V_PF_CODE     IN PROFESSORS.PF_CODE%TYPE
, V_PF_ID       IN PROFESSORS.PF_ID%TYPE
, V_PF_PW       IN PROFESSORS.PF_PW %TYPE
, V_PF_NAME     IN PROFESSORS.PF_NAME%TYPE
, V_PF_SSN      IN PROFESSORS.PF_SSN%TYPE
)
IS
    V_PF_ID2 PROFESSORS.PF_ID%TYPE;
    V_FLAG NUMBER := 0;
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    SELECT COUNT(*) INTO V_PF_ID2
    FROM PROFESSORS
    WHERE PF_CODE NOT IN V_PF_CODE
    AND PF_ID = V_PF_ID;
    
    IF V_PF_ID2 = 1
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    IF IS_NUMBER(SUBSTR(V_PF_SSN,1,6)) = 0
        THEN RAISE_APPLICATION_ERROR(-20044, '숫자만 입력 가능합니다.' );
        ROLLBACK;
    ELSIF IS_NUMBER(SUBSTR(V_PF_SSN,8,14)) = 0
        THEN RAISE_APPLICATION_ERROR(-20044, '숫자만 입력 가능합니다.' );
        ROLLBACK;
    END IF;
    
    UPDATE PROFESSORS
    SET PF_ID = V_PF_ID ,PF_PW = V_PF_PW, PF_NAME = V_PF_NAME, PF_SSN = V_PF_SSN
    WHERE PF_CODE = V_PF_CODE;
    
    EXCEPTION
    WHEN USER_DEFINE_ERROR
        THEN RAISE_APPLICATION_ERROR(-20098, '이미 등록된 ID입니다.' );
        ROLLBACK;
    
    --커밋
    --COMMIT;
END;

-- ◎ 교수 정보 수정 (망곰이 → 이재용)
EXEC PRC_PROFESSORS_UPDATE('PF001', 'SAMSUNG', '이재용', '680623-1357645')


--② 교수 데이터 삭제 트리거 
CREATE OR REPLACE TRIGGER TRG_PROFESSORS_DELETE
-- 자식들을 먼저 다 제거해야 부모테이블에서 삭제 가능하므로 트리거에서 BEFORE 사용  
        BEFORE
        DELETE ON PROFESSORS
        FOR EACH ROW
BEGIN
    DELETE
    FROM DROP_OUT_LISTS
    WHERE REG_CODE IN (SELECT REG_CODE
                        FROM COURSE_REGISTRATIONS
                        WHERE OCRS_CODE IN (SELECT OCRS_CODE
                                             FROM OPEN_COURSES
                                            WHERE PF_CODE = :OLD.PF_CODE));
    DELETE
    FROM SCORES
    WHERE REG_CODE IN (SELECT REG_CODE
                        FROM COURSE_REGISTRATIONS
                        WHERE OCRS_CODE IN (SELECT OCRS_CODE
                                             FROM OPEN_COURSES
                                            WHERE PF_CODE = :OLD.PF_CODE));
    DELETE
    FROM COURSE_REGISTRATIONS
    WHERE OCRS_CODE IN (SELECT OCRS_CODE
                        FROM OPEN_COURSES
                        WHERE PF_CODE = :OLD.PF_CODE);
    DELETE
    FROM OPEN_SUBJECTS
    WHERE OCRS_CODE IN (SELECT OCRS_CODE
                        FROM OPEN_COURSES
                        WHERE PF_CODE = :OLD.PF_CODE);
    DELETE
    FROM OPEN_COURSES
    WHERE PF_CODE = :OLD.PF_CODE;
END;

SELECT *
FROM PROFESSORS;

DELETE 
FROM PROFESSORS
WHERE PF_CODE = 'PF001';



--4. 과정 관리 기능 구현
--1) 최종 관리자는 여러 개의 과정을 미리 등록할 수 있어야 한다.
--   과정 정보 입력은 과정명, 과정 기간(시작, 종료), 강의실 정보를 입력한다.
--   한 개의 과정은 여러 개의 과목으로 구성될 수 있다.(→ 개설 과목 등록 시 확인 가능)

-- ① 과정 데이터 (개설 과정 생성을 위한 작업)
-- 과정 시퀀스 생성
CREATE SEQUENCE COURSES_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;


-- 과정 INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_COURSES_INSERT
( V_CRS_NAME     IN COURSES.CRS_NAME%TYPE
)
IS
    FLAG_COURSES NUMBER; -- FLAG 변수
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    SELECT NVL((SELECT 1
               FROM COURSES
               WHERE CRS_NAME = V_CRS_NAME), 0) INTO FLAG_COURSES
    FROM DUAL;
    
    IF (FLAG_COURSES != 0)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;

    INSERT INTO COURSES(CRS_CODE, CRS_NAME)
    VALUES(('CO' || LPAD(TO_CHAR(COURSES_SEQ.NEXTVAL), 3, '0')), V_CRS_NAME);
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20098, '이미 등록된 과정입니다.' );
            ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
    --커밋
    --COMMIT;
END;

--◎ 과정 데이터 입력
EXEC PRC_COURSES_INSERT('Java를 활용한 Full-Stack개발자 양성과정');
EXEC PRC_COURSES_INSERT('자바와 스프링 기반 빅데이터 Full-stack 개발자 양성과정');
EXEC PRC_COURSES_INSERT('Java(자바)그리고 AWS 활용한 Full-Stack 개발자 양성과정');
EXEC PRC_COURSES_INSERT('자바(Java)기반 Web 이용한 스마트플랫폼 Full-Stack 개발자 양성과정');




-- 과정 UPDATE 프로시저
CREATE OR REPLACE PROCEDURE PRC_COURSES_UPDATE
( V_CRS_CODE     IN COURSES.CRS_CODE%TYPE
, V_CRS_NAME     IN COURSES.CRS_NAME%TYPE
)
IS
    FLAG_COURSES NUMBER; -- FLAG 변수
    USER_DEFINE_ERROR EXCEPTION;
    USER_DEFINE_ERROR1 EXCEPTION;
    COUNT_NUM             NUMBER(2);
    V_START_DATE        DATE;
    
BEGIN

    SELECT COUNT(START_DATE)  INTO COUNT_NUM
    FROM OPEN_COURSES
    WHERE CRS_CODE = V_CRS_CODE;
    
    SELECT MIN(START_DATE)  INTO V_START_DATE
    FROM OPEN_COURSES 
    WHERE CRS_CODE = V_CRS_CODE;
    
    IF (COUNT_NUM !=0)
      THEN  IF(V_START_DATE < SYSDATE)
            THEN RAISE USER_DEFINE_ERROR1;
        END IF;
    END IF;

    SELECT NVL((SELECT 1
               FROM COURSES
               WHERE CRS_NAME = V_CRS_NAME), 0) INTO FLAG_COURSES
    FROM DUAL;
        
    IF (FLAG_COURSES != 0)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    UPDATE COURSES
    SET CRS_NAME = V_CRS_NAME
    WHERE CRS_CODE = V_CRS_CODE;

    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20097, '해당과정은 이미 시작한 과정이므로 정보변경불가' );
            ROLLBACK;
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20098,'이미 등록된 과정입니다.');
            ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
    --커밋
    --COMMIT;
END;

-- ◎ 과정 정보 수정 (Java를 활용한 Full-Stack개발자 양성과정 → 오라클을 활용한 Full-Stack개발자 양성과정 )
EXEC PRC_COURSES_UPDATE('CO001', '오라클을 활용한 Full-Stack개발자 양성과정')


--② 개설 과정 데이터
-- 개설과정 시퀀스 생성
CREATE SEQUENCE OPEN_COURSES_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;

-- 개설과정 INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_OPEN_COURSES_INSERT
( V_CRS_CODE     IN OPEN_COURSES.CRS_CODE%TYPE
, V_PF_CODE      IN OPEN_COURSES.PF_CODE%TYPE
, V_ROOM_CODE    IN OPEN_COURSES.ROOM_CODE%TYPE
, V_START_DATE   IN OPEN_COURSES.START_DATE%TYPE
, V_END_DATE     IN OPEN_COURSES.END_DATE%TYPE
)
IS
    FLAG_COURSES  NUMBER;
    USER_DEFINE_ERROR1    EXCEPTION;
    
    FLAG_CLASSROOMS  NUMBER;
    USER_DEFINE_ERROR2    EXCEPTION;
    
    FLAG_PROFESSORS  NUMBER;
    USER_DEFINE_ERROR3    EXCEPTION;
    
    START_DATE2     OPEN_COURSES.START_DATE%TYPE;
    END_DATE2       OPEN_COURSES.END_DATE%TYPE;
    USER_DEFINE_ERROR4    EXCEPTION;
    
    V_OCRS_CODE       OPEN_COURSES.OCRS_CODE%TYPE;
    
    START_DATE3     OPEN_COURSES.START_DATE%TYPE;
    END_DATE3       OPEN_COURSES.END_DATE%TYPE;
    USER_DEFINE_ERROR5    EXCEPTION;
    USER_DEFINE_ERROR6    EXCEPTION;
    
    CURSOR COURSESCURSOR IS
    SELECT START_DATE, END_DATE
    FROM OPEN_COURSES
    WHERE ROOM_CODE = V_ROOM_CODE;
    
    CURSOR COURSESCURSOR2 IS
    SELECT START_DATE, END_DATE
    FROM OPEN_COURSES
    WHERE PF_CODE = V_PF_CODE;
BEGIN
    -- 시작일이 더 클때 에러발생
    IF V_START_DATE >= V_END_DATE THEN
          RAISE USER_DEFINE_ERROR6;
    END IF;
    
    
    -- 해당 과정이 없을때
    SELECT COUNT(*) INTO FLAG_COURSES
    FROM COURSES
    WHERE CRS_CODE =V_CRS_CODE;
    
    IF (FLAG_COURSES = 0)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;
    
    -- 강의실이 없을때
    SELECT COUNT(*) INTO FLAG_CLASSROOMS
    FROM CLASSROOMS
    WHERE ROOM_CODE = V_ROOM_CODE;
    
    IF (FLAG_CLASSROOMS = 0)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
    
    -- 교수님이 없을때
    SELECT COUNT(*) INTO FLAG_PROFESSORS
    FROM PROFESSORS
    WHERE PF_CODE = V_PF_CODE;
    
    IF (FLAG_PROFESSORS = 0)
        THEN RAISE USER_DEFINE_ERROR3;
    END IF;

    --개설과정 - 강의실
    OPEN COURSESCURSOR;
    LOOP
        FETCH COURSESCURSOR INTO START_DATE2, END_DATE2;
        EXIT WHEN COURSESCURSOR%NOTFOUND;
        IF ((START_DATE2 BETWEEN V_START_DATE AND V_END_DATE) OR (END_DATE2 BETWEEN V_START_DATE AND V_END_DATE) 
            OR (V_START_DATE BETWEEN START_DATE2 AND END_DATE2) OR (V_END_DATE BETWEEN START_DATE2 AND END_DATE2)) THEN
             RAISE USER_DEFINE_ERROR4;
        END IF;
    END LOOP;
    CLOSE COURSESCURSOR;
    
    --개설과정 - 교수
    OPEN COURSESCURSOR2;
    LOOP
        FETCH COURSESCURSOR2 INTO START_DATE3, END_DATE3;
        EXIT WHEN COURSESCURSOR2%NOTFOUND;
        IF ((START_DATE3 BETWEEN V_START_DATE AND V_END_DATE) OR (END_DATE3 BETWEEN V_START_DATE AND V_END_DATE) 
            OR (V_START_DATE BETWEEN START_DATE3 AND END_DATE3) OR (V_END_DATE BETWEEN START_DATE3 AND END_DATE3)) THEN
             RAISE USER_DEFINE_ERROR5;
        END IF;
    END LOOP;
    CLOSE COURSESCURSOR2;

    -- 데이터 입력 쿼리문 구성
    INSERT INTO OPEN_COURSES(OCRS_CODE, CRS_CODE, PF_CODE, ROOM_CODE, START_DATE, END_DATE)
    VALUES(('OC' || LPAD(TO_CHAR(OPEN_COURSES_SEQ.NEXTVAL), 3, '0')), V_CRS_CODE, V_PF_CODE, V_ROOM_CODE, V_START_DATE, V_END_DATE);
    
    
     -- 예외처리
        EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20099, '해당 과정이 없습니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20099, '강의실이 없습니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR3
            THEN RAISE_APPLICATION_ERROR(-20099, '담당 교수님이 없습니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR4
            THEN RAISE_APPLICATION_ERROR(-20099, '기간 내에 같은 강의실이 존재합니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR5
            THEN RAISE_APPLICATION_ERROR(-20099, '기간 내에 같은 교수님이 존재합니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR6
            THEN RAISE_APPLICATION_ERROR(-20099, '종료일이 시작일 보다 빠릅니다. 날짜를 확인해주세요.');
            ROLLBACK;
END;

--◎ 개설 과정 데이터 입력
EXEC PRC_OPEN_COURSES_INSERT('CO001', 'PF001', 'CR001', '2023-08-11', '2023-10-31')
EXEC PRC_OPEN_COURSES_INSERT('CO001', 'PF002', 'CR002', '2023-10-01', '2023-12-31')
EXEC PRC_OPEN_COURSES_INSERT('CO002', 'PF003', 'CR003', '2023-12-01', '2024-03-30')
EXEC PRC_OPEN_COURSES_INSERT('CO002', 'PF004', 'CR004', '2023-12-31', '2024-05-30')

SELECT *
FROM OPEN_COURSES;

--2) 관리자는 등록된 모든 과정의 정보를 출력하여 볼 수 있어야 한다.
--   출력 정보는 과정명, 강의실, 과목명, 과목 기간(시작일, 종료일), 교재 명, 교수자 명을 출력한다.

-- VIEW 생성
CREATE OR REPLACE VIEW VIEW_COURSES
AS
SELECT A.CRS_NAME "과정명", C.ROOM_NAME "강의실", D.SUB_NAME "과목명", E.SUB_START_DATE "시작일", E.SUB_END_DATE "종료일", F.BK_NAME "교재명", G.PF_NAME "교수자명"
FROM COURSES A, OPEN_COURSES B, CLASSROOMS C, SUBJECTS D, OPEN_SUBJECTS E, BOOKS F, PROFESSORS G
WHERE A.CRS_CODE = B.CRS_CODE
AND B.ROOM_CODE = C.ROOM_CODE
AND D.SUB_CODE = E.SUB_CODE
AND B.OCRS_CODE = E.OCRS_CODE
AND E.BK_CODE = F.BK_CODE
AND B.PF_CODE = G.PF_CODE;


--◎ VIEW  조회
SELECT *
FROM VIEW_COURSES;


--3) 관리자는 입력된 과정 정보에 대해 ①수정, ②삭제할 수 있어야 한다.

-- ① 개설 과정 정보 UPDATE 프로시저
CREATE OR REPLACE PROCEDURE PRC_OPEN_COURSES_UPDATE
( V_OCRS_CODE    IN OPEN_COURSES.OCRS_CODE%TYPE
, V_CRS_CODE     IN OPEN_COURSES.CRS_CODE%TYPE
, V_PF_CODE      IN OPEN_COURSES.PF_CODE%TYPE
, V_ROOM_CODE    IN OPEN_COURSES.ROOM_CODE%TYPE
, V_START_DATE   IN OPEN_COURSES.START_DATE%TYPE
, V_END_DATE     IN OPEN_COURSES.END_DATE%TYPE
)
IS
    SUBJECTS_START  OPEN_SUBJECTS.SUB_START_DATE%TYPE;
    SUBJECTS_END    OPEN_SUBJECTS.SUB_END_DATE%TYPE;
    V_OSUB_CODE     OPEN_SUBJECTS.OSUB_CODE%TYPE;
    END_DATE2     OPEN_COURSES.END_DATE%TYPE;
    START_DATE2     OPEN_COURSES.START_DATE%TYPE;
    
    FLAG_COURSES  NUMBER;
    USER_DEFINE_ERROR1    EXCEPTION;
    
    FLAG_CLASSROOMS  NUMBER;
    USER_DEFINE_ERROR2    EXCEPTION;
    
    FLAG_PROFESSORS  NUMBER;
    USER_DEFINE_ERROR3    EXCEPTION;
    
    
    USER_DEFINE_ERROR4    EXCEPTION;
    
    USER_DEFINE_ERROR5    EXCEPTION;
    
    USER_DEFINE_ERROR6    EXCEPTION;

    START_DATE3     OPEN_COURSES.START_DATE%TYPE;
    END_DATE3       OPEN_COURSES.END_DATE%TYPE;
    USER_DEFINE_ERROR7    EXCEPTION;
    
    CURSOR SUBJECTSCURSOR IS
    SELECT OSUB_CODE, SUB_END_DATE
    FROM OPEN_SUBJECTS
    WHERE OCRS_CODE = V_OCRS_CODE;
    
    
    CURSOR COURSESCURSOR IS
    SELECT START_DATE, END_DATE
    FROM OPEN_COURSES
    WHERE ROOM_CODE = V_ROOM_CODE
    AND OCRS_CODE != V_OCRS_CODE;
    
    CURSOR COURSESCURSOR2 IS
    SELECT START_DATE, END_DATE
    FROM OPEN_COURSES
    WHERE PF_CODE = V_PF_CODE
    AND OCRS_CODE != V_OCRS_CODE;
    
BEGIN
    -- 이미 끝난 과정 수정하려고 하면 에러 발생하게 SYSDATE랑 과정종료일이랑 비교
    SELECT END_DATE INTO END_DATE2
    FROM OPEN_COURSES
    WHERE OCRS_CODE = V_OCRS_CODE;

    IF SYSDATE > END_DATE2 THEN
        RAISE USER_DEFINE_ERROR6;
    END IF;
    
    -- 해당 과정이 없을때
    SELECT COUNT(*) INTO FLAG_CLASSROOMS
    FROM CLASSROOMS
    WHERE ROOM_CODE = V_ROOM_CODE;
    
    IF (FLAG_COURSES = 0)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;
    
    -- 강의실이 없을때
    SELECT COUNT(*) INTO FLAG_CLASSROOMS
    FROM CLASSROOMS
    WHERE ROOM_CODE = V_ROOM_CODE;
    
    IF (FLAG_CLASSROOMS = 0)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
    
    -- 교수님이 없을때
    SELECT COUNT(*) INTO FLAG_PROFESSORS
    FROM PROFESSORS
    WHERE PF_CODE = V_PF_CODE;
    
    IF (FLAG_PROFESSORS = 0)
        THEN RAISE USER_DEFINE_ERROR3;
    END IF;
    
    --개설과목 - 개설과정 커서
    OPEN SUBJECTSCURSOR;
    LOOP
        FETCH SUBJECTSCURSOR INTO V_OSUB_CODE, SUBJECTS_END;
            -- 바꾸는 개설과정종료일 >= 개설과목 종료일
            IF (V_END_DATE < SUBJECTS_END) THEN
                 RAISE USER_DEFINE_ERROR4;
            END IF;
            EXIT WHEN SUBJECTSCURSOR%NOTFOUND;
    END LOOP;
    CLOSE SUBJECTSCURSOR;
    
    
    --개설과정 - 강의실
    OPEN COURSESCURSOR;
    LOOP
        FETCH COURSESCURSOR INTO START_DATE2, END_DATE2;
                EXIT WHEN COURSESCURSOR%NOTFOUND;
            IF ((START_DATE2 BETWEEN V_START_DATE AND V_END_DATE) OR (END_DATE2 BETWEEN V_START_DATE AND V_END_DATE) 
            OR (V_START_DATE BETWEEN START_DATE2 AND END_DATE2) OR (V_END_DATE BETWEEN START_DATE2 AND END_DATE2)) THEN
                 RAISE USER_DEFINE_ERROR5;
            END IF;

    END LOOP;
    CLOSE COURSESCURSOR;
    
    --개설과정 - 교수
    OPEN COURSESCURSOR2;
    LOOP
        FETCH COURSESCURSOR2 INTO START_DATE3, END_DATE3;
        EXIT WHEN COURSESCURSOR2%NOTFOUND;
        IF ((START_DATE3 BETWEEN V_START_DATE AND V_END_DATE) OR (END_DATE3 BETWEEN V_START_DATE AND V_END_DATE) 
            OR (V_START_DATE BETWEEN START_DATE3 AND END_DATE3) OR (V_END_DATE BETWEEN START_DATE3 AND END_DATE3)) THEN
             RAISE USER_DEFINE_ERROR7;
        END IF;
    END LOOP;
    CLOSE COURSESCURSOR2;
    
    -- 데이터 수정 쿼리문 구성
    UPDATE OPEN_COURSES
    SET CRS_CODE = V_CRS_CODE, PF_CODE = V_PF_CODE, ROOM_CODE = V_ROOM_CODE, START_DATE = V_START_DATE, END_DATE = V_END_DATE
    WHERE OCRS_CODE = V_OCRS_CODE;
    -- 예외처리
        EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20099, '해당 과정이 없습니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20099, '강의실이 없습니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR3
            THEN RAISE_APPLICATION_ERROR(-20099, '담당 교수님이 없습니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR4
            THEN RAISE_APPLICATION_ERROR(-20099, '에러 발생');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR5
            THEN RAISE_APPLICATION_ERROR(-20099, '기간 내에 같은 강의실이 존재합니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR6
            THEN RAISE_APPLICATION_ERROR(-20099, '이미 종료된 과정입니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR7
            THEN RAISE_APPLICATION_ERROR(-20099, '기간 내에 같은 교수님이 존재합니다.');
            ROLLBACK;
END;

--◎ 개설 과정 UPDATE 확인
/*
OC003	CO002	PF003	CR003	2023-12-01	2024-03-30
*/
EXEC PRC_OPEN_COURSES_UPDATE('OC003', 'CO004', 'PF006', 'CR007', '2023-12-01', '2024-03-13')

SELECT *
FROM OPEN_COURSES;


-- ② 개설 과정 삭제 트리거
CREATE OR REPLACE TRIGGER TRG_OPEN_COURSES_DELETE
        BEFORE
        DELETE ON OPEN_COURSES
        FOR EACH ROW
BEGIN        
        IF (:OLD.START_DATE <= SYSDATE )
            THEN RAISE_APPLICATION_ERROR(-20005, '현재 강의중이거나 완료된 과정으로 삭제가 불가능합니다.');
        END IF;       
        
        --성적 삭제 코드
        DELETE
        FROM SCORES -- 성적
        WHERE OSUB_CODE IN ( SELECT OSUB_CODE 
                             FROM OPEN_SUBJECTS -- 개설 과목
                             WHERE OCRS_CODE = :OLD.OCRS_CODE);
       
         --수강 신청 삭제 코드
        DELETE
        FROM COURSE_REGISTRATIONS
        WHERE OCRS_CODE = :OLD.OCRS_CODE;       
 
        --개설 과목 삭제 코드 
        DELETE 
        FROM OPEN_SUBJECTS -- 개설 과목
        WHERE OCRS_CODE = :OLD.OCRS_CODE;
        
END;



--5. 과목 관리 기능 구현
--1) 관리자는 한 개 과정 당 여러 개의 과목을 미리 등록할 수 있어야 한다.
--   각 과목은 담당 교수를 미리 배정할 수 있다.
--   필요한 경우 담당 교수자 배정을 변경할 수 있다. (→ 개설 과정 UPDATE 프로시저에서 가능)
--   과목 정보 입력은 과정명, 과목명, 과목기간(시작일, 종료일), 교재 명, 교수자 명 정보를 입력할 수 있어야 한다.
--   각 과목은 성적 처리의 대상이 되며, 성적 처리는 출결, 실기, 필기로 구성된다.

-- ① 과목 데이터 (개설 과목 생성을 위한 작업)
-- 과목 시퀀스 생성
CREATE SEQUENCE SUBJECTS_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;


-- 과목 INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_SUBJECTS_INSERT
(V_SUB_NAME     IN SUBJECTS.SUB_NAME%TYPE
)
IS  
    DUP_CHECK NUMBER; -- FLAG 변수
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    
    SELECT NVL((SELECT 1
               FROM SUBJECTs
               WHERE SUB_NAME = V_SUB_NAME), 0) INTO DUP_CHECK
    FROM DUAL;
    
    IF (DUP_CHECK != 0)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    -- 과목 인서트
    INSERT INTO SUBJECTS(SUB_CODE, SUB_NAME)
    VALUES(('SB' || LPAD(TO_CHAR(SUBJECTS_SEQ.NEXTVAL), 3, '0')), V_SUB_NAME);
    
    -- 예외처리
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20098, '이미 등록된 과목입니다.' );
            ROLLBACK;
            
    -- 커밋
    --COMMIT;
END;


--◎ 과목 데이터 입력
EXEC PRC_SUBJECTS_INSERT('Java');
EXEC PRC_SUBJECTS_INSERT('Oracle');
EXEC PRC_SUBJECTS_INSERT('JavaScript');
EXEC PRC_SUBJECTS_INSERT('JSP');
EXEC PRC_SUBJECTS_INSERT('HTML');
EXEC PRC_SUBJECTS_INSERT('CSS');
EXEC PRC_SUBJECTS_INSERT('Python');
EXEC PRC_SUBJECTS_INSERT('Spring Framework');
EXEC PRC_SUBJECTS_INSERT('C++');


-- 과목 UPDATE 프로시저
CREATE OR REPLACE PROCEDURE PRC_SUBJECTS_UPDATE
( V_SUB_CODE IN SUBJECTS.SUB_CODE%TYPE   
, V_SUB_NAME IN SUBJECTS.SUB_NAME%TYPE
)
IS
    DUP_CHECK NUMBER; -- FLAG 변수
    USER_DEFINE_ERROR EXCEPTION;
    USER_DEFINE_ERROR2 EXCEPTION;
    COURSE_START        OPEN_COURSES.START_DATE%TYPE;
    FLAG    NUMBER;
    V_OCRS_CODE OPEN_SUBJECTS.OCRS_CODE%TYPE;
    FLAG2   NUMBER;
    USER_DEFINE_ERROR3 EXCEPTION;
BEGIN
    SELECT NVL((SELECT 1
               FROM SUBJECTs
               WHERE SUB_NAME = V_SUB_NAME), 0) INTO DUP_CHECK
    FROM DUAL;
        
    IF (DUP_CHECK != 0)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    SELECT COUNT(*) INTO FLAG2
    FROM SUBJECTS
    WHERE SUB_CODE = V_SUB_CODE;
    
    IF (FLAG2 = 0)
        THEN RAISE USER_DEFINE_ERROR3;
    END IF;
    
    /*
    SELECT OCRS_CODE
    FROM OPEN_SUBJECTS
    WHERE SUB_CODE = V_SUB_CODE;
    */
    
    SELECT MAX(START_DATE) INTO COURSE_START
    FROM OPEN_COURSES
    WHERE OCRS_CODE IN (SELECT OCRS_CODE
                        FROM OPEN_SUBJECTS
                        WHERE SUB_CODE = V_SUB_CODE);
    
    SELECT COUNT(*) INTO FLAG
    FROM OPEN_SUBJECTS
    WHERE SUB_CODE = V_SUB_CODE;
    
    IF (FLAG != 0 AND SYSDATE > COURSE_START)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
    
    -- 과목 업데이트
    UPDATE SUBJECTS
    SET SUB_NAME = V_SUB_NAME
    WHERE SUB_CODE = V_SUB_CODE;
    
    -- 예외처리
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20098, '이미 등록된 과목입니다.' );
            ROLLBACK;
        WHEN USER_DEFINE_ERROR3
            THEN RAISE_APPLICATION_ERROR(-20096, '해당 과목은 존재하지 않습니다.' );
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20097, '이미 종료된 과목입니다.' );
            ROLLBACK;
            
    -- 커밋
    --COMMIT;
    
END;

--◎ 과목 데이터 수정
EXEC PRC_SUBJECTS_UPDATE('SB001', 'JAVA')

SELECT *
FROM SUBJECTS


-- 과목 삭제 프로시저
CREATE OR REPLACE PROCEDURE PRC_SUBJECTS_DELETE
( V_SUB_CODE IN SUBJECTS.SUB_CODE%TYPE
)
IS
    V_OSUB_CODE OPEN_SUBJECTS.OSUB_CODE%TYPE;
    FLAG    NUMBER;
    FLAG2   NUMBER;
    USER_DEFINE_ERROR2 EXCEPTION;
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    SELECT COUNT(*) INTO FLAG2
    FROM  SUBJECTS
    WHERE SUB_CODE = V_SUB_CODE;
    
    IF (FLAG2 = 0)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;

    SELECT COUNT(*) INTO FLAG
    FROM OPEN_SUBJECTS
    WHERE SUB_CODE = V_SUB_CODE;
    
    IF (FLAG != 0)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    DELETE
    FROM SUBJECTS
    WHERE SUB_CODE = V_SUB_CODE;
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20023, '해당 과목은 존재하지 않는 과목입니다.');
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20065, '해당 과목에 개설된 과목이 있습니다. 개설과정을 먼저 삭제해 주세요.');
END;




-- ② 개설 과목 데이터
-- 개설 과목 시퀀스 생성
CREATE SEQUENCE OPEN_SUBJECTS_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;

-- 개설 과목 INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_OPEN_SUBJECTS_INSERT
( V_OCRS_CODE         IN OPEN_SUBJECTS.OCRS_CODE%TYPE
, V_SUB_CODE          IN OPEN_SUBJECTS.SUB_CODE%TYPE
, V_BK_CODE           IN OPEN_SUBJECTS.BK_CODE%TYPE
, V_SUB_START_DATE    IN OPEN_SUBJECTS.SUB_START_DATE%TYPE
, V_SUB_END_DATE      IN OPEN_SUBJECTS.SUB_END_DATE%TYPE
, V_ATTENDANCE_SCORE  IN OPEN_SUBJECTS.ATTENDANCE_SCORE%TYPE
, V_WRITTEN_SCORE     IN OPEN_SUBJECTS.WRITTEN_SCORE%TYPE
, V_PRACTICAL_SCORE   IN OPEN_SUBJECTS.PRACTICAL_SCORE%TYPE
)
IS  
    COURSE_START        OPEN_COURSES.START_DATE%TYPE;
    COURSE_END          OPEN_COURSES.END_DATE%TYPE;
    OLD_SUB_START_DATE  OPEN_SUBJECTS.SUB_START_DATE%TYPE;
    OLD_SUB_END_DATE    OPEN_SUBJECTS.SUB_END_DATE%TYPE;
    FLAG_COURSE  NUMBER;
    FLAG_BOOK    NUMBER;
    FLAG_SUBJECT NUMBER;
    USER_DEFINE_ERROR    EXCEPTION;  -- 배점의 총합이 100이 아닐 경우 에러 발생
    USER_DEFINE_ERROR2   EXCEPTION; -- 개설 과목이 개설 과정의 기간 내가 아닐 경우 에러 발생
    USER_DEFINE_ERROR3   EXCEPTION; -- 다른 과목이랑 기간이 겹치는 경우 에러 발생
    USER_DEFINE_ERROR4   EXCEPTION; -- 해당 과정이 없을 경우 에러 발생
    USER_DEFINE_ERROR5   EXCEPTION; -- 해당 교재가 없을 경우 에러 발생
    USER_DEFINE_ERROR6   EXCEPTION; -- 해당 과목이 없을 경우 에러 발생
    
    CURSOR CUR_OPEN_SUBJECTS_DATE_SELECT
    IS 
    SELECT SUB_START_DATE, SUB_END_DATE
    FROM OPEN_SUBJECTS
    WHERE OCRS_CODE = V_OCRS_CODE; 
BEGIN
    
    -- 해당 과정이 없을 경우 에러 발생
    SELECT COUNT(*) INTO FLAG_COURSE
    FROM OPEN_COURSES
    WHERE OCRS_CODE = V_OCRS_CODE;
    
    IF (FLAG_COURSE = 0)
        THEN RAISE USER_DEFINE_ERROR4;
    END IF;
    
    -- 배점의 총합이 100이 아닐 경우 에러 발생
    IF (V_ATTENDANCE_SCORE + V_WRITTEN_SCORE + V_PRACTICAL_SCORE != 100)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    -- 개설 과목이 개설 과정의 기간 내가 아닐 경우 에러 발생
    SELECT START_DATE, END_DATE INTO  COURSE_START , COURSE_END
    FROM OPEN_COURSES
    WHERE OCRS_CODE = V_OCRS_CODE;
    
    IF (V_SUB_START_DATE < COURSE_START OR COURSE_END  < V_SUB_END_DATE)
           THEN RAISE USER_DEFINE_ERROR2;  
    END IF;
    
    -- 다른 과목이랑 기간이 겹치는 경우 에러 발생
    OPEN CUR_OPEN_SUBJECTS_DATE_SELECT;
        LOOP
            
        FETCH CUR_OPEN_SUBJECTS_DATE_SELECT INTO OLD_SUB_START_DATE, OLD_SUB_END_DATE;
        
        EXIT WHEN CUR_OPEN_SUBJECTS_DATE_SELECT%NOTFOUND;
  
        IF (V_SUB_START_DATE > OLD_SUB_START_DATE AND V_SUB_END_DATE < OLD_SUB_END_DATE)
            THEN RAISE USER_DEFINE_ERROR3;
        ELSIF (V_SUB_START_DATE < OLD_SUB_END_DATE AND V_SUB_END_DATE > OLD_SUB_END_DATE)
            THEN RAISE USER_DEFINE_ERROR3;
        ELSIF (V_SUB_START_DATE < OLD_SUB_START_DATE AND V_SUB_END_DATE > OLD_SUB_START_DATE)
            THEN RAISE USER_DEFINE_ERROR3;
        END IF;
       
        END LOOP;
    
    CLOSE CUR_OPEN_SUBJECTS_DATE_SELECT;
    
    -- 해당 교재가 없을 경우 에러 발생
    SELECT COUNT(*) INTO FLAG_BOOK
    FROM BOOKS
    WHERE BK_CODE = V_BK_CODE;
    
    IF (FLAG_BOOK = 0)
        THEN RAISE USER_DEFINE_ERROR5;
    END IF;
    
    -- 해당 과목이 없을 경우 에러 발생
    SELECT COUNT(*) INTO FLAG_SUBJECT
    FROM SUBJECTS
    WHERE SUB_CODE = V_SUB_CODE;
    
    IF (FLAG_SUBJECT = 0)
        THEN RAISE USER_DEFINE_ERROR6;
    END IF;
    
    -- 개설 과목  INSERT
    INSERT INTO OPEN_SUBJECTS(OSUB_CODE, OCRS_CODE, SUB_CODE, BK_CODE, SUB_START_DATE, SUB_END_DATE, ATTENDANCE_SCORE, WRITTEN_SCORE, PRACTICAL_SCORE)
    VALUES('OS' || LPAD(TO_CHAR(OPEN_SUBJECTS_SEQ.NEXTVAL), 3, '0'), V_OCRS_CODE, V_SUB_CODE, V_BK_CODE, V_SUB_START_DATE, V_SUB_END_DATE
    , V_ATTENDANCE_SCORE, V_WRITTEN_SCORE, V_PRACTICAL_SCORE);
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20099, '출결, 필기, 실기 배점의 총합이 100이 되게 입력해 주세요.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR4
            THEN RAISE_APPLICATION_ERROR(-20095, '해당 과정이 없습니다');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR5
            THEN RAISE_APPLICATION_ERROR(-20095, '해당 교재가 없습니다');
            ROLLBACK;
         WHEN USER_DEFINE_ERROR6
            THEN RAISE_APPLICATION_ERROR(-20094, '해당 과목이 없습니다');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20097, '과정의 기간안에 과목을 등록해주세요.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR3
            THEN RAISE_APPLICATION_ERROR(-20096, '다른 과목의 기간과 겹칩니다.');
            ROLLBACK;
        
    
    --커밋
    --COMMIT;
END;


--◎ 개설 과목 데이터 입력
EXEC PRC_OPEN_SUBJECTS_INSERT('OC005','SB001','BK006', '2023-08-11', '2023-09-30',30,30,40)
EXEC PRC_OPEN_SUBJECTS_INSERT('OC005','SB002','BK005', '2023-09-30', '2023-10-31',30,30,40)

EXEC PRC_OPEN_SUBJECTS_INSERT('OC003','SB007','BK001', '2023-12-01', '2024-01-31',20,30,50)
EXEC PRC_OPEN_SUBJECTS_INSERT('OC003','SB009','BK011', '2024-02-01', '2024-03-30',50,30,20)


SELECT *
FROM OPEN_SUBJECTS;

SELECT *
FROM OPEN_COURSES;


--2) 각 항목의 배점은 담당 교수자가 결정한다.
--   총 배점은 100점 만점을 기준으로 한다.
-- 배점 UPDATE 프로시저
CREATE OR REPLACE PROCEDURE PR_SCORE_UPDATE
( V_PF_ID               PROFESSORS.PF_ID%TYPE
, V_OSUB_CODE           OPEN_SUBJECTS.OSUB_CODE%TYPE
, V_ATTENDANCE_SCORE    OPEN_SUBJECTS.ATTENDANCE_SCORE%TYPE
, V_WRITTEN_SCORE       OPEN_SUBJECTS.WRITTEN_SCORE%TYPE
, V_PRACTICAL_SCORE     OPEN_SUBJECTS.PRACTICAL_SCORE%TYPE
)
IS
    PF_CODE_TEMP     PROFESSORS.PF_CODE%TYPE;
    OCRS_CODE_TEMP   OPEN_COURSES.OCRS_CODE%TYPE;
    OSUB_CODE_TEMP   OPEN_SUBJECTS.OSUB_CODE%TYPE; 
    PF_ID_TEMP       PROFESSORS.PF_ID%TYPE;
    COUNT_NUM1       NUMBER(2);
    COUNT_NUM2       NUMBER(2);
    
    USER_DEFINE_ERROR1  EXCEPTION;
    USER_DEFINE_ERROR2  EXCEPTION;
    USER_DEFINE_ERROR3  EXCEPTION;
    
BEGIN

    SELECT COUNT(*) INTO COUNT_NUM1
    FROM PROFESSORS
    WHERE PF_ID = V_PF_ID;
    
    -- 입력한 교수 ID가 존재하지 않을 때, ERROR1 발생시킴  
    IF (COUNT_NUM1 = 0)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    
    SELECT PF_CODE, PF_ID INTO PF_CODE_TEMP, PF_ID_TEMP
    FROM PROFESSORS
    WHERE PF_ID = V_PF_ID;
    
    SELECT OCRS_CODE   INTO OCRS_CODE_TEMP 
    FROM OPEN_COURSES
    WHERE PF_CODE = PF_CODE_TEMP;

    -- 입력한 교수ID가 포함된 개설과정, 개설 코드가 있을 경우 카운트
    SELECT COUNT(OSUB_CODE) INTO COUNT_NUM2  
    FROM OPEN_SUBJECTS
    WHERE OCRS_CODE = OCRS_CODE_TEMP
      AND OSUB_CODE = V_OSUB_CODE;
      
    -- 입력한 개설 과목 코드가 교수 담당 개설 과목이 아닐 때(카운트가 1이 아닐 때), ERROR2 발생 시킴
    IF (COUNT_NUM2 = 0)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;  

                   
    -- 배점이 총합이 100이 아닐 때, ERROR3 발생시킴
    IF (V_ATTENDANCE_SCORE + V_WRITTEN_SCORE + V_PRACTICAL_SCORE != 100)
        THEN RAISE USER_DEFINE_ERROR3;
    END IF;   
    
    UPDATE OPEN_SUBJECTS
    SET ATTENDANCE_SCORE = V_ATTENDANCE_SCORE
      , WRITTEN_SCORE = V_WRITTEN_SCORE
      , PRACTICAL_SCORE = V_PRACTICAL_SCORE
    WHERE OSUB_CODE = V_OSUB_CODE;
        
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20001, '교수ID가 존재하지 않습니다.');
                ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20002, '일치하는 과목 CODE가 없습니다.');
                ROLLBACK;
        WHEN USER_DEFINE_ERROR3
            THEN RAISE_APPLICATION_ERROR(-20003, '배점이 총합이 100이 아닙니다.');
                ROLLBACK;
            WHEN OTHERS
                THEN ROLLBACK;  
END;


--3) 관리자는 등록된 모든 과목의 정보를 출력하여 볼 수 있어야 한다.
--   출력 정보는 과정명, 강의실, 과목명, 과목 기간(시작일, 종료일), 교재 명, 교수 명을 출력한다.

--조회 VIEW 생성
CREATE VIEW VIEW_SUB_MANAGE 
AS
SELECT B.CRS_NAME "과정명", C.ROOM_NAME "강의실", D.SUB_NAME "과목명", E.SUB_START_DATE "시작일", E.SUB_END_DATE "종료일", F.BK_NAME "교재명", G.PF_NAME "교수명"
FROM OPEN_COURSES A, COURSES B, CLASSROOMS C, SUBJECTS D, OPEN_SUBJECTS E, BOOKS F, PROFESSORS G
WHERE A.CRS_CODE = B.CRS_CODE
  AND A.ROOM_CODE = C.ROOM_CODE
  AND D.SUB_CODE = E.SUB_CODE
  AND A.OCRS_CODE = E.OCRS_CODE
  AND E.BK_CODE = F.BK_CODE
  AND A.PF_CODE = G.PF_CODE
ORDER BY 2;

SELECT *
FROM VIEW_SUB_MANAGE;


--4) 관리자는 입력된 과목 정보에 대해 ① 수정, ② 삭제할 수 있어야 한다.

-- ① 개설 과목 정보 수정
-- 개설 과목 UPDATE 프로시저
CREATE OR REPLACE PROCEDURE PRC_OPEN_SUBJECTS_UPDATE
( V_OSUB_CODE         IN OPEN_SUBJECTS.OSUB_CODE%TYPE
, V_OCRS_CODE         IN OPEN_SUBJECTS.OCRS_CODE%TYPE
, V_SUB_CODE          IN OPEN_SUBJECTS.SUB_CODE%TYPE
, V_BK_CODE           IN OPEN_SUBJECTS.BK_CODE%TYPE
, V_SUB_START_DATE    IN OPEN_SUBJECTS.SUB_START_DATE%TYPE
, V_SUB_END_DATE      IN OPEN_SUBJECTS.SUB_END_DATE%TYPE
, V_ATTENDANCE_SCORE  IN OPEN_SUBJECTS.ATTENDANCE_SCORE%TYPE
, V_WRITTEN_SCORE     IN OPEN_SUBJECTS.WRITTEN_SCORE%TYPE
, V_PRACTICAL_SCORE   IN OPEN_SUBJECTS.PRACTICAL_SCORE%TYPE
)
IS  
    COURSE_START        OPEN_COURSES.START_DATE%TYPE;
    COURSE_END          OPEN_COURSES.END_DATE%TYPE;
    OLD_SUB_START_DATE  OPEN_SUBJECTS.SUB_START_DATE%TYPE;
    OLD_SUB_END_DATE    OPEN_SUBJECTS.SUB_END_DATE%TYPE;
    FLAG_COURSE  NUMBER;
    FLAG_BOOK    NUMBER;
    FLAG_SUBJECT NUMBER;
    FLAG_OPEN_SUBJECT NUMBER;
    FLAG    NUMBER;
    P_OCRS_CODE OPEN_SUBJECTS.OCRS_CODE%TYPE;
    
    USER_DEFINE_ERROR    EXCEPTION;  -- 배점의 총합이 100이 아닐 경우 에러 발생
    USER_DEFINE_ERROR2   EXCEPTION; -- 개설 과목이 개설 과정의 기간 내가 아닐 경우 에러 발생
    USER_DEFINE_ERROR3   EXCEPTION; -- 다른 과목이랑 기간이 겹치는 경우 에러 발생
    USER_DEFINE_ERROR4   EXCEPTION; -- 해당 과정이 없을 경우 에러 발생
    USER_DEFINE_ERROR5   EXCEPTION; -- 해당 교재가 없을 경우 에러 발생
    USER_DEFINE_ERROR6   EXCEPTION; -- 해당 과목이 없을 경우 에러 발생
    USER_DEFINE_ERROR7   EXCEPTION; -- 해당 개설 과목이 없을 경우 에러발생
    USER_DEFINE_ERROR8   EXCEPTION; -- 이미 끝난 개설 과목을 수정하려고 하는 경우 에러 발생
    
    CURSOR CUR_OPEN_SUBJECTS_DATE_SELECT
    IS 
    SELECT SUB_START_DATE, SUB_END_DATE
    FROM OPEN_SUBJECTS
    WHERE OCRS_CODE = V_OCRS_CODE; 
BEGIN
    
    -- 배점의 총합이 100이 아닐 경우 에러 발생
    IF (V_ATTENDANCE_SCORE + V_WRITTEN_SCORE + V_PRACTICAL_SCORE != 100)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    -- 해당 과정이 없을 경우 에러 발생
    SELECT COUNT(*) INTO FLAG_COURSE
    FROM OPEN_COURSES
    WHERE OCRS_CODE = V_OCRS_CODE;
    
    IF (FLAG_COURSE = 0)
        THEN RAISE USER_DEFINE_ERROR4;
    END IF;
    
    -- 개설 과목이 개설 과정의 기간 내가 아닐 경우 에러 발생
    SELECT START_DATE, END_DATE INTO  COURSE_START , COURSE_END
    FROM OPEN_COURSES
    WHERE OCRS_CODE = V_OCRS_CODE;
    
    IF (V_SUB_START_DATE < COURSE_START OR COURSE_END  < V_SUB_END_DATE)
           THEN RAISE USER_DEFINE_ERROR2;  
    END IF;
    
    -- 다른 과목이랑 기간이 겹치는 경우 에러 발생
    OPEN CUR_OPEN_SUBJECTS_DATE_SELECT;
        LOOP
            
        FETCH CUR_OPEN_SUBJECTS_DATE_SELECT INTO OLD_SUB_START_DATE, OLD_SUB_END_DATE;
        
        EXIT WHEN CUR_OPEN_SUBJECTS_DATE_SELECT%NOTFOUND;
  
        IF (V_SUB_START_DATE > OLD_SUB_START_DATE AND V_SUB_END_DATE < OLD_SUB_END_DATE)
            THEN RAISE USER_DEFINE_ERROR3;
        ELSIF (V_SUB_START_DATE < OLD_SUB_END_DATE AND V_SUB_END_DATE > OLD_SUB_END_DATE)
            THEN RAISE USER_DEFINE_ERROR3;
        ELSIF (V_SUB_START_DATE < OLD_SUB_START_DATE AND V_SUB_END_DATE > OLD_SUB_START_DATE)
            THEN RAISE USER_DEFINE_ERROR3;
        END IF;
       
        END LOOP;
    
    CLOSE CUR_OPEN_SUBJECTS_DATE_SELECT;
    
    
    -- 해당 교재가 없을 경우 에러 발생
    SELECT COUNT(*) INTO FLAG_BOOK
    FROM BOOKS
    WHERE BK_CODE = V_BK_CODE;
    
    IF (FLAG_BOOK = 0)
        THEN RAISE USER_DEFINE_ERROR5;
    END IF;
    
    -- 해당 과목이 없을 경우 에러 
    SELECT COUNT(*) INTO FLAG_SUBJECT
    FROM SUBJECTS
    WHERE SUB_CODE = V_SUB_CODE;
    
    IF (FLAG_SUBJECT = 0)
        THEN RAISE USER_DEFINE_ERROR6;
    END IF;
    
    -- 해당 개설과목이 없을 경우 에러 발생
    SELECT COUNT(*) INTO FLAG_OPEN_SUBJECT
    FROM OPEN_SUBJECTS
    WHERE OSUB_CODE = V_OSUB_CODE;
    
    IF (FLAG_OPEN_SUBJECT = 0)
        THEN RAISE USER_DEFINE_ERROR7;
    END IF;
    
    -- 이미 끝난 개설 과목을 수정하려고 하는 경우 에러 발생
    SELECT OCRS_CODE INTO P_OCRS_CODE
    FROM OPEN_SUBJECTS
    WHERE OSUB_CODE = V_OSUB_CODE;
    
    SELECT COUNT(*) INTO FLAG
    FROM COURSE_REGISTRATIONS
    WHERE OCRS_CODE = P_OCRS_CODE;
    
    IF (FLAG != 0 AND SYSDATE > COURSE_START)
        THEN RAISE USER_DEFINE_ERROR8;
    END IF;
    
    -- 개설 과목 UPDATE
    UPDATE OPEN_SUBJECTS
    SET OCRS_CODE = V_OCRS_CODE, SUB_CODE = V_SUB_CODE, BK_CODE = V_BK_CODE, SUB_START_DATE = V_SUB_START_DATE, SUB_END_DATE = V_SUB_END_DATE
      , ATTENDANCE_SCORE = V_ATTENDANCE_SCORE, WRITTEN_SCORE = V_WRITTEN_SCORE, PRACTICAL_SCORE = V_PRACTICAL_SCORE
    WHERE OSUB_CODE = V_OSUB_CODE;
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20099, '출결, 필기, 실기 배점의 총합이 100이 되게 입력해 주세요.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR4
            THEN RAISE_APPLICATION_ERROR(-20095, '해당 과정이 없습니다');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR5
            THEN RAISE_APPLICATION_ERROR(-20094, '해당 교재가 없습니다');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR6
            THEN RAISE_APPLICATION_ERROR(-20093, '해당 과목이 없습니다');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR7
            THEN RAISE_APPLICATION_ERROR(-20092, '해당 개설 과목이 없습니다');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20097, '과정의 기간안에 과목을 등록해주세요.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR3
            THEN RAISE_APPLICATION_ERROR(-20096, '다른 과목의 기간과 겹칩니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR8
            THEN RAISE_APPLICATION_ERROR(-20091, '이미 종료된 개설과정의 과목을 수정할 수 없습니다.');
            ROLLBACK;
    --커밋
    --COMMIT;
END;

--◎ 개설 과목 UPDATE 실행
/*
OS003	OC003	SB009	BK011	2024-02-01	2024-03-30	50	30	20
*/
EXEC PRC_OPEN_SUBJECTS_UPDATE('OS003', 'OC019', 'SB008', 'BK010', '2024-02-01', '2024-03-30', 40, 20, 40)

/*
OS003	OC003	SB005	BK010	2024-02-01	2024-03-30	40	20	40
*/


--② 개설 과목 정보 삭제
-- 개설 과목 삭제 트리거
CREATE OR REPLACE PROCEDURE PRC_OPEN_SUBJECTS_DELETE
( V_OSUB_CODE IN OPEN_SUBJECTS.OSUB_CODE%TYPE
)
IS
    V_OCRS_CODE OPEN_SUBJECTS.OCRS_CODE%TYPE;
    FLAG    NUMBER;
    FLAG2   NUMBER;
    USER_DEFINE_ERROR2 EXCEPTION;
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    
    SELECT COUNT(*) INTO FLAG2
    FROM OPEN_SUBJECTS
    WHERE OSUB_CODE = V_OSUB_CODE;
    
    IF (FLAG2 = 0)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
    
    SELECT OCRS_CODE INTO V_OCRS_CODE
    FROM OPEN_SUBJECTS
    WHERE OSUB_CODE = V_OSUB_CODE;
    
    SELECT COUNT(*) INTO FLAG
    FROM COURSE_REGISTRATIONS
    WHERE OCRS_CODE = V_OCRS_CODE;
    
    IF (FLAG != 0)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    DELETE
    FROM OPEN_SUBJECTS
    WHERE OSUB_CODE = V_OSUB_CODE;
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20066, '해당 개설과목은 존재하지 않습니다.');
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20066, '이미 수강신청된 과정의 과목에 대해서는 삭제 할 수 없습니다.');
END;


--6. 학생 관리 기능 구현

--1) 최종 관리자는 한 개 과정당 여러 명의 학생을 미리 등록할 수 있어야 한다. (→ 과정에 등록하는 것은 수강신청 INSERT 프로시저에서 실행)
--   입력 정보는 학생 이름, 주민등록번호 뒷자리를 기본으로 등록하고,
--   주민등록번호 뒷자리는 학생 본인이 로그인 시 패스워드로 사용되도록 한다.

-- 학생 데이터 시퀀스 생성
CREATE SEQUENCE STUDENTS_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;

-- 학생 데이터 INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_STUDENTS_INSERT
( V_ST_ID       IN STUDENTS.ST_ID%TYPE
, V_ST_NAME     IN STUDENTS.ST_NAME%TYPE
, V_ST_SSN      IN STUDENTS.ST_SSN%TYPE
)
IS
    V_ST_PW  STUDENTS.ST_PW%TYPE;  -- PW를 담을 변수
    FLAG_ID  NUMBER:=0;
    USER_DEFINE_ERROR1 EXCEPTION;
BEGIN    
    
    -- 주민번호 뒷자리 입력되었을 때, 비밀번호로 설정
    V_ST_PW := SUBSTR(V_ST_SSN,8,14);
    
    SELECT COUNT(*) INTO FLAG_ID
    FROM STUDENTS
    WHERE ST_ID = V_ST_ID;
        
    IF FLAG_ID = 1
        THEN RAISE_APPLICATION_ERROR(-20050, '이미 등록된 ID입니다.' );
        ROLLBACK;
    END IF;
    
    IF IS_NUMBER(SUBSTR(V_ST_SSN,1,6)) = 0
        THEN RAISE_APPLICATION_ERROR(-20044, '숫자만 입력 가능합니다.' );
        ROLLBACK;
    ELSIF IS_NUMBER(SUBSTR(V_ST_SSN,8,14)) = 0
        THEN RAISE_APPLICATION_ERROR(-20044, '숫자만 입력 가능합니다.' );
        ROLLBACK;
    END IF; 
    
    -- 학생 인서트
    INSERT INTO STUDENTS(ST_CODE, ST_ID, ST_PW, ST_NAME, ST_SSN)
    VALUES(('ST' || LPAD(TO_CHAR(STUDENTS_SEQ.NEXTVAL),3,'0')), V_ST_ID, V_ST_PW, V_ST_NAME, V_ST_SSN);
    
   
    -- 커밋
    --COMMIT;   
END;

--◎ 학생 데이터 입력
EXEC PRC_STUDENTS_INSERT('MOON', '문보경', '071212-3022432');
EXEC PRC_STUDENTS_INSERT('OHOH', '오지환', '901007-1544236');
EXEC PRC_STUDENTS_INSERT('KIM', '김상수', '990304-1788896');
EXEC PRC_STUDENTS_INSERT('BON', '신본기', '811112-1566789');
EXEC PRC_STUDENTS_INSERT('SOOOYEON', '지소연', '970922-2312547');
EXEC PRC_STUDENTS_INSERT('MINA', '이민아', '980505-2978541');
EXEC PRC_STUDENTS_INSERT('JANG', '장슬기', '921011-2362514');
EXEC PRC_STUDENTS_INSERT('SONNY', '손흥민', '990810-1552147');
EXEC PRC_STUDENTS_INSERT('HWANG', '황희찬', '951010-1122233');
EXEC PRC_STUDENTS_INSERT('EUNBIN', '박은빈', '010707-2574812');
EXEC PRC_STUDENTS_INSERT('JINI', '황진이', '800301-2020202');
EXEC PRC_STUDENTS_INSERT('KIMMINA', '김미나', '790102-2777777');

SELECT *
FROM STUDENTS;


--2) 관리자는 등록된 모든 학생의 정보를 출력할 수 있어야 한다.
--   출력 정보는 학생 이름, 과정명, 수강과목, 수강과목 총점을 출력한다.
--   과정을 중도 탈락하여 명단에서 제외된 학생인 경우,
--   중도 탈락 사실을 화면에서 확인할 수 있어야 한다.

-- 조회 VIEW 생성
CREATE OR REPLACE VIEW VIEW_STUDENTS_REGISTRATIONS
AS
SELECT ST.ST_NAME"학생이름", CRS.CRS_NAME"과정명", SUB.SUB_NAME"과목명", SC.ATTENDANCE_SCORE + SC.WRITTEN_SCORE + SC.PRACTICAL_SCORE "수강과목총점", NVL(DR.DO_REASON,' ')"중도탈락사유"
FROM COURSE_REGISTRATIONS RG, STUDENTS ST, OPEN_COURSES OCRS, COURSES CRS, OPEN_SUBJECTS OSUB, SUBJECTS SUB, SCORES SC, DROP_OUT_LISTS DO, DROP_REASONS DR                    
WHERE RG.ST_CODE = ST.ST_CODE
  AND RG.OCRS_CODE = OCRS.OCRS_CODE
  AND OCRS.CRS_CODE(+) = CRS.CRS_CODE
  AND OCRS.OCRS_CODE = OSUB.OCRS_CODE
  AND OSUB.SUB_CODE = SUB.SUB_CODE
  AND RG.REG_CODE(+) = SC.REG_CODE
  AND OSUB.OSUB_CODE = SC.OSUB_CODE
  AND RG.REG_CODE = DO.REG_CODE(+)
  AND DO.DO_REASON_CODE = DR.DO_REASON_CODE(+)
UNION
SELECT ST.ST_NAME"학생이름", CRS.CRS_NAME"과정명", SUB.SUB_NAME"과목명", NVL(SC.ATTENDANCE_SCORE + SC.WRITTEN_SCORE + SC.PRACTICAL_SCORE,-1) "수강과목총점", NVL(DR.DO_REASON,' ')"중도탈락사유"
FROM COURSE_REGISTRATIONS RG, STUDENTS ST, OPEN_COURSES OCRS, COURSES CRS, OPEN_SUBJECTS OSUB, SUBJECTS SUB, SCORES SC, DROP_OUT_LISTS DO, DROP_REASONS DR                    
WHERE RG.ST_CODE = ST.ST_CODE(+)
  AND RG.OCRS_CODE = OCRS.OCRS_CODE(+)
  AND OCRS.CRS_CODE = CRS.CRS_CODE(+)
  AND OCRS.OCRS_CODE = OSUB.OCRS_CODE(+)
  AND OSUB.SUB_CODE = SUB.SUB_CODE(+)
  AND OSUB.OSUB_CODE = SC.OSUB_CODE(+)
  AND RG.REG_CODE = DO.REG_CODE(+)
  AND DO.DO_REASON_CODE = DR.DO_REASON_CODE(+)
  AND OSUB.SUB_END_DATE > SYSDATE
UNION
SELECT ST.ST_NAME"학생이름", CRS.CRS_NAME"과정명", SUB.SUB_NAME"과목명", -1 "수강과목총점",NVL(DR.DO_REASON,' ')"중도탈락사유"
FROM COURSE_REGISTRATIONS RG, STUDENTS ST, DROP_OUT_LISTS DO, DROP_REASONS DR, OPEN_COURSES OCRS, COURSES CRS, OPEN_SUBJECTS OSUB, SUBJECTS SUB, SCORES SC
WHERE RG.ST_CODE = ST.ST_CODE(+)
  AND RG.REG_CODE = DO.REG_CODE(+)
  AND DO.DO_REASON_CODE = DR.DO_REASON_CODE(+)
  AND RG.OCRS_CODE = OCRS.OCRS_CODE(+)
  AND OCRS.CRS_CODE = CRS.CRS_CODE(+)
  AND OCRS.OCRS_CODE = OSUB.OCRS_CODE(+)
  AND OSUB.SUB_CODE = SUB.SUB_CODE(+)
  AND DO.DO_DATE < OSUB.SUB_END_DATE
  AND RG.REG_CODE = SC.REG_CODE
UNION
SELECT ST.ST_NAME, '수강중인 과정 없음' "과정명", ' ' "과목명", 0 "수강과목총점",'해당 없음'"중도탈락사유"
FROM STUDENTS ST, COURSE_REGISTRATIONS RG
WHERE ST.ST_CODE = RG.ST_CODE(+)
  AND REG_CODE IS NULL;

  
CREATE OR REPLACE VIEW VIEW_STUDENTS_REGISTRATIONS
AS  
SELECT S.ST_NAME"학생이름", NVL(C.CRS_NAME, '-')"과정명", NVL(S.SUB_NAME, '-')"과목명"
     , NVL(TO_CHAR((SC.ATTENDANCE_SCORE + SC.WRITTEN_SCORE + SC.PRACTICAL_SCORE)), '-')"총점", DECODE(SUBSTR(DO_CODE,1,2), 'DR', '중도 탈락', '-') "중도탈락여부"
FROM STUDENTS S LEFT JOIN COURSE_REGISTRATIONS REG
ON S.ST_CODE = REG.ST_CODE
LEFT JOIN OPEN_COURSES OC
ON REG.OCRS_CODE = OC.OCRS_CODE
LEFT JOIN OPEN_SUBJECTS OS
ON OC.OCRS_CODE = OS.OCRS_CODE
LEFT JOIN COURSES C
ON C.CRS_CODE = OC.CRS_CODE
LEFT JOIN SUBJECTS S
ON S.SUB_CODE = OS.SUB_CODE
LEFT JOIN SCORES SC
ON SC.REG_CODE = REG.REG_CODE
LEFT JOIN DROP_OUT_LISTS DO
ON DO.REG_CODE = REG.REG_CODE


--◎ VIEW 조회
SELECT *
FROM VIEW_STUDENTS_REGISTRATIONS;



--3) 관리자는 입력된 학생 정보에 대해 ① 수정, ② 삭제할 수 있어야 한다.
--① 학생 정보 수정
-- 학생 정보 UPDATE 프로시저
CREATE OR REPLACE PROCEDURE PRC_STUDENTS_UPDATE
( V_ST_CODE     IN STUDENTS.ST_CODE%TYPE
, V_ST_ID       IN STUDENTS.ST_ID%TYPE
, V_ST_PW       IN STUDENTS.ST_PW%TYPE
, V_ST_NAME     IN STUDENTS.ST_NAME%TYPE
, V_ST_SSN      IN STUDENTS.ST_SSN%TYPE
)
IS
    FLAG_ID NUMBER; -- FLAG 변수
    USER_DEFINE_ERROR1 EXCEPTION;   -- 데이터 중복시 에러 
BEGIN

    
    -- 예외처리    
    SELECT COUNT(*) INTO FLAG_ID
    FROM STUDENTS
    WHERE ST_CODE NOT IN V_ST_CODE
      AND ST_ID = V_ST_ID;

    IF FLAG_ID = 1
        THEN RAISE_APPLICATION_ERROR(-20050, '이미 등록된 ID입니다.' );
        ROLLBACK;
    END IF;
    
    IF IS_NUMBER(SUBSTR(V_ST_SSN,1,6)) = 0
        THEN RAISE_APPLICATION_ERROR(-20044, '숫자만 입력 가능합니다.' );
        ROLLBACK;
    ELSIF IS_NUMBER(SUBSTR(V_ST_SSN,8,14)) = 0
        THEN RAISE_APPLICATION_ERROR(-20044, '숫자만 입력 가능합니다.' );
        ROLLBACK;
    END IF; 
          
    UPDATE STUDENTS
    SET ST_ID = V_ST_ID
       ,ST_PW = V_ST_PW
       ,ST_NAME = V_ST_NAME
       ,ST_SSN = V_ST_SSN
    WHERE ST_CODE = V_ST_CODE;

    -- 커밋
    --COMMIT;   
END;


--◎ 학생 정보 수정 수행
/*
ST001	MOON	3022432	문보경	071212-3022432	2023-11-15
*/
EXEC PRC_STUDENTS_UPDATE('ST001', 'DONG', '문보동', '071212-3022467')

/*
ST001	DONG	3022467	문보동	071212-3022467	2023-11-15
*/


--② 학생 정보 삭제
-- 학생 정보 삭제 트리거
CREATE OR REPLACE TRIGGER TRG_STUDENTS_DELETE
        BEFORE
        DELETE ON STUDENTS
        FOR EACH ROW
BEGIN
    -- 성적 삭제
    DELETE
    FROM SCORES
    WHERE REG_CODE = (SELECT REG_CODE
                      FROM COURSE_REGISTRATIONS
                      WHERE ST_CODE = :OLD.ST_CODE);
    -- 중도탈락 삭제
    DELETE
    FROM DROP_OUT_LISTS
    WHERE REG_CODE = (SELECT REG_CODE
                      FROM COURSE_REGISTRATIONS
                      WHERE ST_CODE = :OLD.ST_CODE);
    -- 수강신청 삭제                  
    DELETE
    FROM COURSE_REGISTRATIONS
    WHERE ST_CODE = :OLD.ST_CODE;               
                     
END;


-- ★ 요구분석서에는 없지만 필수로 필요한 수강신청 과정!------------------------
-- 수강신청 데이터 시퀀스 생성
CREATE SEQUENCE COURSE_REGISTRAIONS_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;


-- 수강신청 데이터 입력 프로시저
CREATE OR REPLACE PROCEDURE PRC_COURSES_REG
( V_ST_CODE     IN COURSE_REGISTRATIONS.ST_CODE%TYPE
, V_OCRS_CODE   IN COURSE_REGISTRATIONS.OCRS_CODE%TYPE
)
IS
    OCRS_COUNT NUMBER;     			              -- 개설 과정 카운트 변수
    USER_DEFINE_ERROR1 EXCEPTION;
    
    ST_COUNT NUMBER;        			          -- 학생 카운트 변수
    USER_DEFINE_ERROR2 EXCEPTION;
    
    V_OCRS_START  OPEN_COURSES.START_DATE%TYPE;   -- 개설과정 시작일
    V_ST_DATE STUDENTS.ST_DATE%TYPE;              -- 학생 등록일 
    USER_DEFINE_ERROR3 EXCEPTION;   
    
    ST_OCRS NUMBER;    				               -- 학생이 신청한 수강신청 카운트
    USER_DEFINE_ERROR4 EXCEPTION;
    
    V_ST_OCRS COURSE_REGISTRATIONS.OCRS_CODE%TYPE; -- 학생이 신청한 개설과정 코드
    USER_DEFINE_ERROR5 EXCEPTION;  
    
    ---- 커서 정의	
    CURSOR CUR_RG_INSERT
    IS 
    SELECT START_DATE, END_DATE
    FROM OPEN_COURSES
    WHERE OCRS_CODE IN (SELECT OCRS_CODE
                         FROM COURSE_REGISTRATIONS
                         WHERE ST_CODE = V_ST_CODE);  


    ---- 커서 변수 선언
    OCRS_START  OPEN_COURSES.START_DATE%TYPE;
    OCRS_END    OPEN_COURSES.END_DATE%TYPE;
    
    C_OCRS_START  OPEN_COURSES.START_DATE%TYPE;
    C_OCRS_END    OPEN_COURSES.END_DATE%TYPE;        
 
    USER_DEFINE_ERROR6 EXCEPTION;

BEGIN

    -- 1) 입력한 과정이 없을 경우 예외 처리
    -- 개설 과정 테이블에 입력한 과정에 대한 카운트가 나오도록 했다.
    -- 개설 과정이 있을경우 1 아닐경우 0이 나온다.
    SELECT COUNT(*) INTO OCRS_COUNT
    FROM OPEN_COURSES 
    WHERE OCRS_CODE = V_OCRS_CODE; 
    
    -- 카운트가 1이 아닐 때 즉, 과정이 없을경우 에러 발생
    IF (OCRS_COUNT != 1)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;    

     -- 2) 학생 코드가 없을 경우 예외 처리
     -- 학생 테이블에 입력한 학생 코드에 대한 카운트가 나오도록 했다.
     -- 학생이 있을경우 1 아닐경우 0이 나온다.
     SELECT COUNT(*) INTO ST_COUNT
     FROM STUDENTS
     WHERE ST_CODE = V_ST_CODE;
    
    -- 카운트가 0일 때 즉, 학생이 없을 경우 에러 발생
    IF (ST_COUNT = 0)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
    
    -- 3) 이미 신청한 과정일 경우 예외 처리
    -- 수강신청 테이블에 입력 받은 학생코드, 개설과정이 같은 데이터에 대한 카운트가 나오도록 했다. 
    -- 이미 신청할 과정일 경우 1 아닐경우 0이 나온다. 
    SELECT COUNT(*) INTO ST_OCRS 
    FROM COURSE_REGISTRATIONS
    WHERE OCRS_CODE = V_OCRS_CODE
      AND ST_CODE = V_ST_CODE;
    
    -- 카운트가 0이 아닐때 즉, 이미 신청한 과정일 경우 에러 발생  
    IF (ST_OCRS != 0)
        THEN RAISE USER_DEFINE_ERROR4;
    END IF;

    
    -- 4) 과정날짜가 겹칠 경우 예외 처리
    -- 입력 받은 개설 과정에 시작 날짜와 종료 날짜를 변수에 담는다.
    SELECT START_DATE, END_DATE INTO C_OCRS_START, C_OCRS_END
    FROM OPEN_COURSES
    WHERE OCRS_CODE = V_OCRS_CODE;
    
    -- 커서 오픈
    OPEN CUR_RG_INSERT;
    
    LOOP
    -- 커서에서 나온 시작 날짜를 변수 OCRS_START, 종료 날짜를 변수 OCRS_END 에 넣는다. 
    -- 입력 받은 학생이 신청한 개설 과정에 대한 시작날짜와 종료 날짜이다.
    FETCH CUR_RG_INSERT INTO OCRS_START, OCRS_END;
         
        -- 입력 받은 학생이 지금까지 신청한 개설 과정 날짜와 새로 신청하는 개설 과정 날짜를 비교하여 날짜가 겹칠경우 에러 발생                 
        IF ((C_OCRS_START BETWEEN OCRS_START AND OCRS_END) OR (C_OCRS_END BETWEEN OCRS_START AND OCRS_END) OR 
             (OCRS_START BETWEEN C_OCRS_START AND C_OCRS_END) OR (OCRS_END BETWEEN C_OCRS_START AND C_OCRS_END))
            THEN RAISE USER_DEFINE_ERROR6;   
        END IF;
         
         -- 더이상 커서에 값이 없을 경우 루프를 나간다.
         EXIT WHEN CUR_RG_INSERT%NOTFOUND;
    
    END LOOP;
    -- 커서 클로즈 
    CLOSE CUR_RG_INSERT;
   
     -- 5) 학생 등록일 보다 과정 시작일이 빠를경우
     -- 입력 받은 학생의 등록일을 변수 V_ST_DATE 에 넣는다.
    SELECT ST_DATE INTO V_ST_DATE
    FROM STUDENTS
    WHERE ST_CODE = V_ST_CODE;
    
    -- 신청하는 개설 과정의 시작 날짜를 변수 V_OCRS_START 에 넣는다.
    SELECT START_DATE INTO V_OCRS_START    
    FROM OPEN_COURSES
    WHERE OCRS_CODE = V_OCRS_CODE;  
    
    -- 학생 등록일과 개설과정 시작 날짜를 비교하여 등록일이 더 미래일 경우 에러 발생
    IF (V_ST_DATE > V_OCRS_START )
        THEN RAISE USER_DEFINE_ERROR3;
    END IF;
    
     -- 6) 이미 과정이 시작 되었을경우 예외처리
     -- 개설 과정 시작 날짜와 오늘(신청일) 날짜를 비교하여 시작 날짜가 과거일 경우 에러 발생
    IF (V_OCRS_START < SYSDATE)
        THEN RAISE USER_DEFINE_ERROR5;
    END IF;

    -- 수강신청 INSERT
    INSERT INTO COURSE_REGISTRATIONS (ST_CODE, OCRS_CODE, REG_CODE, REG_DATE)
    VALUES (V_ST_CODE, V_OCRS_CODE, 'RE' || LPAD(TO_CHAR(COURSE_REGISTRAIONS_SEQ.NEXTVAL),3,'0'),SYSDATE);
    
    
    -- 예외처리 문
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20004,'입력한 과정이 없습니다.');
                 ROLLBACK;
                 
        WHEN USER_DEFINE_ERROR2 
            THEN RAISE_APPLICATION_ERROR(-20004,'입력한 학생은 없습니다.');
                ROLLBACK;
                
        WHEN USER_DEFINE_ERROR3    
            THEN RAISE_APPLICATION_ERROR(-20005,'학생 등록일이 수강신청 날짜보다 더 늦습니다.');
                ROLLBACK;
                                
        WHEN USER_DEFINE_ERROR4
            THEN RAISE_APPLICATION_ERROR(-20006,'이미 등록한 과정입니다.');
                ROLLBACK;
                
        WHEN USER_DEFINE_ERROR5
            THEN RAISE_APPLICATION_ERROR(-20005,'이미 시작된 과정입니다.');
                ROLLBACK;
                
        WHEN USER_DEFINE_ERROR6
            THEN RAISE_APPLICATION_ERROR(-20006,'기간이 같은 과정은 신청이 불가합니다.');
                ROLLBACK;         
--        WHEN OTHERS
--            THEN ROLLBACK;
        --커밋
        --COMMIT;
END;


EXEC PRC_COURSES_REG ('ST001', 'OC005');

SELECT *
FROM OPEN_COURSES;

SELECT *
FROM COURSE_REGISTRATIONS;



-- 수강 끝난 과목 수강신청 데이터에 넣기 위한 임의 INSERT 수행
INSERT INTO COURSE_REGISTRATIONS(REG_CODE , ST_CODE, OCRS_CODE,REG_DATE)
VALUES ('RG001','ST001','OC001',TO_DATE('2023-07-01','YYYY-MM-DD'));

INSERT INTO COURSE_REGISTRATIONS(REG_CODE , ST_CODE, OCRS_CODE,REG_DATE)
VALUES ('RG002','ST002','OC001',TO_DATE('2023-07-15','YYYY-MM-DD'));

INSERT INTO COURSE_REGISTRATIONS(REG_CODE , ST_CODE, OCRS_CODE,REG_DATE)
VALUES ('RG003','ST003','OC002',TO_DATE('2023-09-25','YYYY-MM-DD'));

INSERT INTO COURSE_REGISTRATIONS(REG_CODE , ST_CODE, OCRS_CODE,REG_DATE)
VALUES ('RG004','ST004','OC002',TO_DATE('2023-09-20','YYYY-MM-DD'));

-- 수강신청 데이터 업데이트 프로시저
CREATE OR REPLACE PROCEDURE PRC_REG_UPDATE
( V_REG_CODE        COURSE_REGISTRATIONS.REG_CODE%TYPE
, V_ST_ID           STUDENTS.ST_ID%TYPE
, V_OCRS_CODE       OPEN_COURSES.OCRS_CODE%TYPE  -- 이 과정으로 수강신청을 변경하고자 한다~
)
IS
    ST_CODE_TEMP    STUDENTS.ST_CODE%TYPE;
    OCRS_CODE_TEMP  OPEN_COURSES.OCRS_CODE%TYPE;
    
    START_DATE_TEMP  OPEN_COURSES.START_DATE%TYPE;
    
    
    C_OCRS_START  OPEN_COURSES.START_DATE%TYPE;
    C_OCRS_END    OPEN_COURSES.START_DATE%TYPE;
    
    OCRS_START  OPEN_COURSES.END_DATE%TYPE;
    OCRS_END    OPEN_COURSES.END_DATE%TYPE;
    
    COUNT_NUM1   NUMBER(2);
    COUNT_NUM2   NUMBER(2);
    COUNT_NUM3   NUMBER(2);
    
    USER_DEFINE_ERROR1  EXCEPTION;
    USER_DEFINE_ERROR2  EXCEPTION;
    USER_DEFINE_ERROR3  EXCEPTION;
    USER_DEFINE_ERROR4  EXCEPTION;
    USER_DEFINE_ERROR5  EXCEPTION;
    
    CURSOR CUR_RG_UPDATE
    IS 
    SELECT START_DATE, END_DATE
    FROM OPEN_COURSES
    WHERE OCRS_CODE IN (SELECT OCRS_CODE
                         FROM COURSE_REGISTRATIONS
                         WHERE ST_CODE = ST_CODE_TEMP); 
    
BEGIN


    SELECT COUNT(*)  INTO COUNT_NUM3
    FROM STUDENTS
    WHERE ST_ID = V_ST_ID;
    IF (COUNT_NUM3 =0)
        THEN RAISE USER_DEFINE_ERROR4;
    END IF;
    
    
    SELECT ST_CODE  INTO ST_CODE_TEMP
    FROM STUDENTS
    WHERE ST_ID = V_ST_ID;
    
    SELECT COUNT(*) INTO COUNT_NUM2
    FROM COURSE_REGISTRATIONS
    WHERE OCRS_CODE  =V_OCRS_CODE
    AND ST_CODE=ST_CODE_TEMP;
    
    IF (COUNT_NUM2 =1)
        THEN RAISE USER_DEFINE_ERROR3;
    END IF;
    
    
    SELECT COUNT(*) INTO COUNT_NUM1
    FROM COURSE_REGISTRATIONS
    WHERE ST_CODE = ST_CODE_TEMP
      AND REG_CODE = V_REG_CODE;
    
    IF (COUNT_NUM1 !=1)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;
    
       
    SELECT OCRS_CODE INTO OCRS_CODE_TEMP
    FROM COURSE_REGISTRATIONS
    WHERE ST_CODE = ST_CODE_TEMP
      AND REG_CODE = V_REG_CODE;
    
    
    SELECT START_DATE   INTO START_DATE_TEMP
    FROM OPEN_COURSES
    WHERE OCRS_CODE = V_OCRS_CODE;
    
    IF (START_DATE_TEMP < SYSDATE)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
      
    
    SELECT START_DATE, END_DATE INTO C_OCRS_START, C_OCRS_END
    FROM OPEN_COURSES
    WHERE OCRS_CODE = V_OCRS_CODE;
    
    OPEN CUR_RG_UPDATE;
    
    LOOP
    FETCH CUR_RG_UPDATE INTO OCRS_START, OCRS_END;
                            
        IF ((C_OCRS_START BETWEEN OCRS_START AND OCRS_END) OR (C_OCRS_END BETWEEN OCRS_START AND OCRS_END) OR 
             (OCRS_START BETWEEN C_OCRS_START AND C_OCRS_END) OR (OCRS_END BETWEEN C_OCRS_START AND C_OCRS_END))
            THEN RAISE USER_DEFINE_ERROR5;   
        END IF;
        
         EXIT WHEN CUR_RG_UPDATE%NOTFOUND;
   
    END LOOP;
    
    CLOSE CUR_RG_UPDATE;  
      
      
    
    UPDATE COURSE_REGISTRATIONS
    SET OCRS_CODE = V_OCRS_CODE
    WHERE REG_CODE = V_REG_CODE
      AND ST_CODE = ST_CODE_TEMP;
    
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20001, '일치하는 수강 신청 내역이 존재하지 않습니다.');
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20002, '진행중이거나 종료된 과정이므로 수강신청 변경이 불가합니다.');
        WHEN USER_DEFINE_ERROR3
            THEN RAISE_APPLICATION_ERROR(-20003, '기존 수강 신청 과정과 동일한 과정입니다.');
        WHEN USER_DEFINE_ERROR4
            THEN RAISE_APPLICATION_ERROR(-20003, '일치하는 학생ID가 존재하지 않습니다.');   
        WHEN USER_DEFINE_ERROR5
            THEN RAISE_APPLICATION_ERROR(-20006,' 기간이 같은 과정이므로 업데이트가 불가합니다.');
                ROLLBACK;             
END;



--7. 성적 관리 기능 구현
--1) 과목은 강의한 교수자가 로그인한 후 성적 처리 과정을 진행할 수 있어야 한다.

-- 교수 로그인
CREATE OR REPLACE PROCEDURE PR_LOGIN_PF
( V_PF_ID   IN PROFESSORS.PF_ID%TYPE
, V_PF_PW   IN PROFESSORS.PF_PW%TYPE
)
IS
    COUNT_NUM   NUMBER(2);
    PF_PW2      PROFESSORS.PF_PW%TYPE;
    V_PF_NAME   PROFESSORS.PF_NAME%TYPE;
    USER_DEFINE_ERROR1   EXCEPTION;
    USER_DEFINE_ERROR2   EXCEPTION;
BEGIN
    
    SELECT COUNT(*) INTO COUNT_NUM
    FROM PROFESSORS
    WHERE PF_ID = V_PF_ID;

    IF (COUNT_NUM != 1)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;
    
    SELECT PF_PW    INTO PF_PW2
    FROM PROFESSORS
    WHERE PF_ID = V_PF_ID;
    
    IF (PF_PW2 != V_PF_PW)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
    
    SELECT PF_NAME          INTO V_PF_NAME
    FROM PROFESSORS
    WHERE PF_ID = V_PF_ID
      AND PF_PW = V_PF_PW;
    
    DBMS_OUTPUT.PUT_LINE(V_PF_NAME || '교수님으로 로그인되었습니다.');
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20001, '아이디가 일치하지 않습니다.');
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20002, '비밀번호가 일치하지 않습니다.');   
END;

--2) 각 과목은 성적 처리의 대상이 되며, 성적 처리를 출결, 실기, 필기로 구성된다.
--   각 과목의 배점은 담당 교수자가 결정한다. (배점 UPDATE 프로시저)
--   총 배점은 100점 만점을 기준으로 한다.

-- 성적 데이터 시퀀스 생성
CREATE SEQUENCE SCORES_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;


-- 성적 INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_INSERT_SCORE
( V_PF_CODE              IN PROFESSORS.PF_CODE%TYPE
, V_SUB_CODE             IN SUBJECTS.SUB_CODE%TYPE
, V_REG_CODE             IN SCORES.REG_CODE%TYPE
, V_ATTENDANCE_SCORE     IN SCORES.ATTENDANCE_SCORE%TYPE 
, V_WRITTEN_SCORE        IN SCORES.WRITTEN_SCORE%TYPE
, V_PRACTICAL_SCORE      IN SCORES.PRACTICAL_SCORE%TYPE
, V_TEST_DATE            IN SCORES.TEST_DATE%TYPE
)
IS
    
    V_OSUB_CODE SCORES.OSUB_CODE%TYPE;
    V_A_SCORE   OPEN_SUBJECTS.ATTENDANCE_SCORE%TYPE;
    V_W_SCORE   OPEN_SUBJECTS.WRITTEN_SCORE%TYPE;
    V_P_SCORE   OPEN_SUBJECTS.PRACTICAL_SCORE%TYPE;
    V_SUB_END   OPEN_SUBJECTS.SUB_END_DATE%TYPE;
    HMM         NUMBER:=0;
    HA          NUMBER:=0;

BEGIN        
   -- 개설과목코드 뽑기
   SELECT  COUNT(*) INTO HMM 
   FROM SCORES S    FULL JOIN
                     OPEN_SUBJECTS OS
                    ON OS.OSUB_CODE= S.OSUB_CODE
                    FULL JOIN OPEN_COURSES OC
                    ON  OC.OCRS_CODE=OS.OCRS_CODE
                    FULL JOIN COURSE_REGISTRATIONS CR
                    ON CR.OCRS_CODE=OC.OCRS_CODE                  
                    
   WHERE OS.SUB_CODE = V_SUB_CODE
     AND OC.PF_CODE  = V_PF_CODE
     AND CR.REG_CODE = V_REG_CODE;
  
    IF (HMM=0)
     THEN RAISE_APPLICATION_ERROR(-20007, '조건에 맞는 학생이없습니다.');
       ROLLBACK;
   END IF;
  
  SELECT  OS.OSUB_CODE INTO  V_OSUB_CODE
   FROM SCORES S    FULL JOIN
                     OPEN_SUBJECTS OS
                    ON OS.OSUB_CODE= S.OSUB_CODE
                    FULL JOIN OPEN_COURSES OC
                    ON  OC.OCRS_CODE=OS.OCRS_CODE
                    FULL JOIN COURSE_REGISTRATIONS CR
                    ON CR.OCRS_CODE=OC.OCRS_CODE                  
                    
   WHERE OS.SUB_CODE = V_SUB_CODE
     AND OC.PF_CODE  = V_PF_CODE
     AND CR.REG_CODE = V_REG_CODE;
  
  
   SELECT COUNT(*) INTO HA
   FROM SCORES
   WHERE REG_CODE = V_REG_CODE;
  
  
    IF(HA>0)
        THEN  RAISE_APPLICATION_ERROR(-20005, '이미 성적입력을 했습니다.');
      ROLLBACK;       
    END IF;
   
    --과목 끝나는 날짜 뽑기
    SELECT  SUB_END_DATE INTO V_SUB_END
    FROM    OPEN_SUBJECTS
    WHERE   OSUB_CODE = V_OSUB_CODE;
    
    -- 과목별 배점점수 뽑기
    SELECT ATTENDANCE_SCORE,WRITTEN_SCORE,PRACTICAL_SCORE INTO V_A_SCORE ,V_W_SCORE, V_P_SCORE
    FROM OPEN_SUBJECTS
    WHERE SUB_CODE = V_SUB_CODE;
    
    --예외처리
    
    IF((V_ATTENDANCE_SCORE>V_A_SCORE) OR (V_WRITTEN_SCORE>V_W_SCORE) OR (V_PRACTICAL_SCORE>V_P_SCORE))
        THEN  RAISE_APPLICATION_ERROR(-20005, '배점보다 더 높게 점수를 부여할 수 없습니다.');
      ROLLBACK;       
    END IF;
    
     IF(V_SUB_END >SYSDATE)
        THEN 
            RAISE_APPLICATION_ERROR(-20006, '아직 과목기간이 끝나지 않았습니다.');
       ROLLBACK; 
    END IF;

    -- 입력구문
    INSERT INTO SCORES(SCORE_CODE, REG_CODE, OSUB_CODE, ATTENDANCE_SCORE, WRITTEN_SCORE, PRACTICAL_SCORE, TEST_DATE)
    VALUES(('SC' || LPAD(TO_CHAR(SCORES_SEQ.NEXTVAL), 3, '0')), V_REG_CODE, V_OSUB_CODE, V_ATTENDANCE_SCORE, V_WRITTEN_SCORE , V_PRACTICAL_SCORE , V_TEST_DATE);

    --COMMIT;
END;

--◎ 성적 데이터 입력
EXEC PRC_INSERT_SCORE('PF001', 'SB001', 'RG001', 25, 30, 30, '2023-09-30')
EXEC PRC_INSERT_SCORE('PF001', 'SB001', 'RG002', 30, 10, 15, '2023-09-30')


--★ 요구분석서에는 없지만 필수로 필요한 중도탈락 데이터 입력 과정-----------------
-- 중도탈락 리스트 데이터 시퀀스 생성
CREATE SEQUENCE DROP_OUT_LISTS_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9999
NOCYCLE
NOCACHE;

-- 중도탈락 리스트 INSERT 프로시저
CREATE OR REPLACE PROCEDURE PRC_DO_LISTS_INSERT
( V_REG_CODE          IN COURSE_REGISTRATIONS.REG_CODE%TYPE
, V_DO_REASON_CODE    IN DROP_REASONS.DO_REASON_CODE%TYPE
, V_DO_DATE           IN DROP_OUT_LISTS.DO_DATE%TYPE 
)
IS      
        COUNT_NUM NUMBER;
        
        OCRS_CODE_TEMP  OPEN_COURSES.OCRS_CODE%TYPE;
        START_DATE_TEMP OPEN_COURSES.START_DATE%TYPE;
        END_DATE_TEMP   OPEN_COURSES.START_DATE%TYPE;
        
        USER_DEFINE_ERROR1 EXCEPTION;
        USER_DEFINE_ERROR2 EXCEPTION;
        USER_DEFINE_ERROR3 EXCEPTION;
BEGIN
        
        SELECT OCRS_CODE    INTO OCRS_CODE_TEMP
        FROM COURSE_REGISTRATIONS
        WHERE REG_CODE = V_REG_CODE;
        
        SELECT START_DATE, END_DATE INTO START_DATE_TEMP, END_DATE_TEMP
        FROM OPEN_COURSES
        WHERE OCRS_CODE_TEMP = OCRS_CODE;
        
        -- 수강 신청한 내역의 과정이 아직 시작하지 않았을 경우 중도탈락 불가
        IF (START_DATE_TEMP > SYSDATE)
            THEN RAISE USER_DEFINE_ERROR1;
        END IF;
        
        IF (END_DATE_TEMP < SYSDATE)
            THEN RAISE USER_DEFINE_ERROR2;
        END IF;
         
        SELECT COUNT(REG_CODE) INTO COUNT_NUM
        FROM DROP_OUT_LISTS
        WHERE REG_CODE = V_REG_CODE ;
        
        IF COUNT_NUM = 1
            THEN RAISE USER_DEFINE_ERROR3;
        END IF;
        
        INSERT INTO DROP_OUT_LISTS(DO_CODE , REG_CODE, DO_REASON_CODE, DO_DATE)
        VALUES ('DR' || LPAD(TO_CHAR(DROP_OUT_LISTS_SEQ.NEXTVAL),3,'0'),V_REG_CODE, V_DO_REASON_CODE, V_DO_DATE);
        
        EXCEPTION
            WHEN USER_DEFINE_ERROR1
                THEN RAISE_APPLICATION_ERROR(-20001, '아직 시작되지 않은 과정이므로 중도 탈락 등록이 불가합니다.');
                ROLLBACK;
            WHEN USER_DEFINE_ERROR2
                THEN RAISE_APPLICATION_ERROR(-20002, '이미 수강 종료된 과정이므로 중도 탈락 등록이 불가합니다.');
                ROLLBACK;
            WHEN USER_DEFINE_ERROR3
                THEN RAISE_APPLICATION_ERROR(-20003,'이미 중도 탈락 된 과정입니다.');
                ROLLBACK;
            WHEN OTHERS
                THEN ROLLBACK;
        -- 커밋
        --COMMIT;
END;

--◎ 중도탈락 데이터 입력
EXEC PRC_DO_LISTS_INSERT('RG004', 'DR001',SYSDATE)



--2) 과목을 수강한 학생은 로그인한 후 성적을 확인할 수 있어야 한다.

-- 학생 로그인 프로시저
CREATE OR REPLACE PROCEDURE PR_LOGIN_ST
( V_ST_ID   IN STUDENTS.ST_ID%TYPE
, V_ST_PW   IN STUDENTS.ST_PW%TYPE
)
IS
    COUNT_NUM   NUMBER(2);
    ST_PW2      STUDENTS.ST_PW%TYPE;
    V_ST_NAME   STUDENTS.ST_NAME%TYPE;
    USER_DEFINE_ERROR1   EXCEPTION;
    USER_DEFINE_ERROR2   EXCEPTION;
BEGIN
    
    SELECT COUNT(*) INTO COUNT_NUM
    FROM STUDENTS
    WHERE ST_ID = V_ST_ID;

    IF (COUNT_NUM != 1)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;
    
    SELECT ST_PW    INTO ST_PW2
    FROM STUDENTS
    WHERE ST_ID = V_ST_ID;
    
    IF (ST_PW2 != V_ST_PW)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
    
    SELECT ST_NAME          INTO V_ST_NAME
    FROM STUDENTS
    WHERE ST_ID = V_ST_ID
      AND ST_PW = V_ST_PW;
    
    DBMS_OUTPUT.PUT_LINE(V_ST_NAME || ' 학생으로 로그인되었습니다.');
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20001, '아이디가 일치하지 않습니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20002, '비밀번호가 일치하지 않습니다.');   
            ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
        
END;

EXEC PR_LOGIN_ST('MOON', '3022432')



--3) 여러 개의 과목을 수강한 학생인 경우는 모든 과목을 한 페이지에서 확인할 수 있어야 한다.

-- VIEW 생성
CREATE OR REPLACE VIEW VIEW_SCORE_STUDENTS
AS
SELECT T1.ST_ID, T1.ST_NAME, T6.CRS_NAME, T7.SUB_NAME, T8.PF_NAME, T3.ATTENDANCE_SCORE, T3.WRITTEN_SCORE, T3.PRACTICAL_SCORE, NVL(T10.DO_REASON, '해당 없음')"중도탈락 사유"
FROM STUDENTS T1 JOIN COURSE_REGISTRATIONS T2
ON T1.ST_CODE = T2.ST_CODE
JOIN SCORES T3
ON T2.REG_CODE = T3.REG_CODE
LEFT JOIN OPEN_SUBJECTS T4
ON T3.OSUB_CODE = T4.OSUB_CODE
LEFT JOIN OPEN_COURSES T5
ON T4.OCRS_CODE = T5.OCRS_CODE
LEFT JOIN COURSES T6 --LEFT
ON T5.CRS_CODE = T6.CRS_CODE
JOIN SUBJECTS T7
ON T4.SUB_CODE = T7.SUB_CODE
JOIN PROFESSORS T8
ON T5.PF_CODE = T8.PF_CODE
LEFT JOIN DROP_OUT_LISTS T9
ON T9.REG_CODE = T2.REG_CODE
LEFT JOIN DROP_REASONS T10
ON T9.DO_REASON_CODE = T10.DO_REASON_CODE
ORDER BY 1;

--◎ VIEW 조회
SELECT *
FROM VIEW_SCORE_STUDENTS
WHERE ST_ID ='MOON'


--4) 과정을 중도 탈락하여 명단에서 제외된 학생이더라도
--   이미 수강한 과목에 대해서는 정보가 출력되어야 한다.
--   과정을 중도 탈락하여 명단에서 제외된 학생인 경우,
--   중도 탈락 사실을 화면에서 확인할 수 있어야 한다.

CREATE OR REPLACE VIEW VIEW_SCORE_STUDENTS
AS
SELECT T1.ST_ID, T1.ST_NAME, T6.CRS_NAME, T7.SUB_NAME, T8.PF_NAME, T3.ATTENDANCE_SCORE, T3.WRITTEN_SCORE, T3.PRACTICAL_SCORE, NVL(T10.DO_REASON, '해당 없음')"중도탈락 사유"
FROM STUDENTS T1 JOIN COURSE_REGISTRATIONS T2
ON T1.ST_CODE = T2.ST_CODE
JOIN SCORES T3
ON T2.REG_CODE = T3.REG_CODE
LEFT JOIN OPEN_SUBJECTS T4
ON T3.OSUB_CODE = T4.OSUB_CODE
LEFT JOIN OPEN_COURSES T5
ON T4.OCRS_CODE = T5.OCRS_CODE
LEFT JOIN COURSES T6 --LEFT
ON T5.CRS_CODE = T6.CRS_CODE
JOIN SUBJECTS T7
ON T4.SUB_CODE = T7.SUB_CODE
JOIN PROFESSORS T8
ON T5.PF_CODE = T8.PF_CODE
LEFT JOIN DROP_OUT_LISTS T9
ON T9.REG_CODE = T2.REG_CODE
LEFT JOIN DROP_REASONS T10
ON T9.DO_REASON_CODE = T10.DO_REASON_CODE
ORDER BY 1;

SELECT *
FROM VIEW_SCORE_STUDENTS

CREATE OR REPLACE VIEW VIEW_DROPOUT_LISTS
AS
SELECT T1.ST_ID, T1.ST_NAME, T6.CRS_NAME, CASE WHEN T3.DO_CODE LIKE '%1'
                                                 OR T3.DO_CODE LIKE '%2'
                                                 OR T3.DO_CODE LIKE '%3'
                                                 OR T3.DO_CODE LIKE '%4'
                                                 OR T3.DO_CODE LIKE '%5' THEN '중도탈락'
                                                ELSE '중도 탈락 해당 없음'
                                           END"중도탈락여부",
                                                 T4.DO_REASON
FROM STUDENTS T1 JOIN COURSE_REGISTRATIONS T2
ON T1.ST_CODE = T2.ST_CODE
JOIN DROP_OUT_LISTS T3
ON T2.REG_CODE = T3.REG_CODE
JOIN DROP_REASONS T4
ON T3.DO_REASON_CODE = T4.DO_REASON_CODE
JOIN OPEN_COURSES T5
ON T2.OCRS_CODE = T5.OCRS_CODE
JOIN COURSES T6
ON T5.CRS_CODE = T6.CRS_CODE;

SELECT *
FROM VIEW_DROPOUT_LISTS


--★ 사용자 측 요구분석 (교수자)-------------------------------------------------
--1. 간단한 로그인 과정을 통하여 성적 처리 과정 화면으로 전환될 수 있어야 한다.
--   로그인 과정을 거치면 자신이 강의한 과목이 화면에 출력되고, 
--   이에 대한 성적을 처리할 수 있는 화면으로 전환할 수 있어야 한다.

-- VIEW 생성
CREATE OR REPLACE VIEW VIEW_PF_SUBJECTS
AS
SELECT P.PF_NAME, C.CRS_NAME, S.SUB_NAME
FROM PROFESSORS P JOIN OPEN_COURSES OC
ON P.PF_CODE = OC.PF_CODE
JOIN OPEN_SUBJECTS OS
ON OC.OCRS_CODE = OS.OCRS_CODE
JOIN COURSES C
ON OC.CRS_CODE = C.CRS_CODE
JOIN SUBJECTS S
ON OS.SUB_CODE = S.SUB_CODE

--◎ VIEW 조회
SELECT *
FROM VIEW_PF_SUBJECTS

--2. 성적 입력 기능 구현
--1) 교수자는 입력된 성적 정보에 대해 ①수정, ②삭제할 수 있어야 한다.

--① 성적 UPDATE 프로시저
CREATE OR REPLACE PROCEDURE PRC_UPDATE_SCORE
( V_SCORE_CODE          IN SCORES.SCORE_CODE%TYPE
, V_ATTENDANCE_SCORE    IN SCORES.ATTENDANCE_SCORE%TYPE 
, V_WRITTEN_SCORE       IN SCORES.WRITTEN_SCORE%TYPE
, V_PRACTICAL_SCORE     IN SCORES.PRACTICAL_SCORE%TYPE
)
IS
    COUNT_NUM   NUMBER(2);
    V_A_SCORE   OPEN_SUBJECTS.ATTENDANCE_SCORE%TYPE;
    V_W_SCORE   OPEN_SUBJECTS.WRITTEN_SCORE%TYPE;
    V_P_SCORE   OPEN_SUBJECTS.PRACTICAL_SCORE%TYPE;
    V_SUB_CODE  SUBJECTS.SUB_CODE%TYPE;
    
    USER_DEFINE_ERROR1   EXCEPTION;
    USER_DEFINE_ERROR2   EXCEPTION;
BEGIN        
    
    SELECT COUNT(*) INTO COUNT_NUM
    FROM SCORES
    WHERE SCORE_CODE = V_SCORE_CODE;
    
    IF (COUNT_NUM = 0)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;
     
    SELECT SUB_CODE   INTO  V_SUB_CODE 
    FROM OPEN_SUBJECTS O JOIN SCORES S ON O.OSUB_CODE = S.OSUB_CODE
    WHERE  S.SCORE_CODE = V_SCORE_CODE;
    
  
    --항목별 최대 점수 뽑기
    SELECT ATTENDANCE_SCORE,WRITTEN_SCORE,PRACTICAL_SCORE INTO V_A_SCORE ,V_W_SCORE, V_P_SCORE
    FROM OPEN_SUBJECTS
    WHERE SUB_CODE = V_SUB_CODE;    
    
    IF((V_ATTENDANCE_SCORE>V_A_SCORE) OR (V_WRITTEN_SCORE>V_W_SCORE) OR (V_PRACTICAL_SCORE>V_P_SCORE))
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;
    
    
    --예외처리
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20001, '일치하는 성적 코드(데이터)가 없습니다.');
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20002, '배정된 배점을 초과하는 점수입니다.');
        WHEN OTHERS
            THEN ROLLBACK;
  
    --업데이트 구문
    UPDATE SCORES S
    SET S.ATTENDANCE_SCORE = V_ATTENDANCE_SCORE ,S.WRITTEN_SCORE =V_WRITTEN_SCORE, S.PRACTICAL_SCORE =V_PRACTICAL_SCORE
    WHERE SCORE_CODE = V_SCORE_CODE;
  
    --COMMIT;
END;

--◎ 성적 업데이트 데이터 입력
EXEC PRC_UPDATE_SCORE('SC003', 20, 30, 25)

/*
SC003	RG001	OS005	25	30	30	2023-09-30
*/
--              ↓
/*
SC003	RG001	OS005	20	30	25	2023-09-30
*/


--② 성적 삭제 프로시저
CREATE OR REPLACE PROCEDURE PRC_DELETE_SCORE
( V_SCORE_CODE          IN SCORES.SCORE_CODE%TYPE
)
IS
    COUNT_NUM   NUMBER(2);
    USER_DEFINE_ERROR   EXCEPTION;
    
BEGIN    

    SELECT COUNT(*) INTO COUNT_NUM
    FROM SCORES
    WHERE SCORE_CODE = V_SCORE_CODE;
    
    IF (COUNT_NUM = 0)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20001, '일치하는 성적 코드(데이터)가 없습니다.');
        WHEN OTHERS
            THEN ROLLBACK;
    
   
   --삭제실행구문 
    DELETE 
    FROM SCORES
    WHERE SCORE_CODE = V_SCORE_CODE;
    --COMMIT;
END;


--3. 성적 출력 기능 구현
-- 자신이 강의한 과목에 대한 성적을 최종적으로 출력하여 볼 수 있어야 한다.
-- 출력 정보는 과목명, 과목 기간(시작일, 종료일), 교재 명, 학생 명, 출결, 실기, 필기, 총점, 등수가 출력되어야 한다.
-- 출력은 수강을 한 모든 학생의 정보가 출력되어야 한다.
-- 과정을 중도 탈락하여 명단에서 제외된 학생이더라도 이미 수강한 과목에 대해서는 정보가 출력되어야 한다.
-- 과정을 중도 탈락하여 명단에서 제외된 학생일 때 중도 탈락 사실을 화면에서 확인할 수 있어야 한다.

-- VIEW 생성
CREATE OR REPLACE VIEW VIEW_PROFESSORS_SCORES
AS
SELECT TT.*
FROM
(
    SELECT T.* , T.출결 + T.실기 + T.필기 "총점" , RANK() OVER(PARTITION BY T.과목명 ORDER BY (T.출결 + T.실기 + T.필기) DESC) "등수"
    FROM 
    (
        SELECT J.SUB_NAME "과목명",O.SUB_START_DATE || ' ~ ' || O.SUB_END_DATE "과목기간", B.BK_NAME "교재명", ST.ST_NAME "학생명", S.ATTENDANCE_SCORE "출결", S.PRACTICAL_SCORE "실기", S.WRITTEN_SCORE "필기"
            ,CASE WHEN D.DO_CODE IS NOT NULL THEN '중도탈락'
                  WHEN P.END_DATE < SYSDATE THEN '수료완료'
                  WHEN P.END_DATE > SYSDATE THEN '수료중'             
             ELSE '오류'
             END "중도탈락여부"
             ,PP.PF_ID  "아이디"
        FROM SCORES S JOIN OPEN_SUBJECTS O
          ON S.OSUB_CODE = O.OSUB_CODE
             JOIN SUBJECTS J
             ON J.SUB_CODE = O.SUB_CODE
             JOIN BOOKS B
             ON B.BK_CODE = O.BK_CODE
             JOIN COURSE_REGISTRATIONS C
             ON S.REG_CODE  = C.REG_CODE
             JOIN STUDENTS ST
             ON ST.ST_CODE = C.ST_CODE
             JOIN DROP_OUT_LISTS D
             ON D.REG_CODE = C.REG_CODE
             JOIN OPEN_COURSES P
             ON P.OCRS_CODE = C.OCRS_CODE
             JOIN PROFESSORS PP
             ON PP.PF_CODE = P.PF_CODE            
    )T
)TT;



--◎ VIEW 조회
SELECT 과목명, 과목기간, 교재명, 학생명, 출결, 실기, 필기, 총점, 등수, 중도탈락여부
FROM VIEW_PROFESSORS_SCORES
WHERE 아이디 = 'CHUNSIK';



--★ 사용자 측 요구분석 (학생)
--1. 로그인 기능 구현
-- 간단한 로그인 과정을 통하여 성적 확인 화면으로 전환될 수 있어야 한다.
-- 과정을 중도 탈락하여 명단에서 제외된 학생이더라도 로그인할 수 있어야 한다.
-- 과정을 중도 탈락하여 명단에서 제외된 학생이 로그인한 경우는 중도 탈락된 사실을 화면에서 확인할 수 있어야 한다.

-- 학생 로그인 프로시저(중도탈락 확인 가능)
CREATE OR REPLACE PROCEDURE LOGIN_STUDENT
(  V_ST_ID           IN STUDENTS.ST_ID%TYPE
,  V_ST_PW           IN STUDENTS.ST_PW%TYPE
)
IS
    V_DR_REASON    DROP_REASONS.DO_REASON%TYPE;
    V_COUNT        NUMBER(1):=0;
    ST_NAME_TEMP   STUDENTS.ST_NAME%TYPE;
    DO_LIST_TEMP   VARCHAR2(20);

BEGIN

    SELECT COUNT(*)  INTO V_COUNT
    FROM STUDENTS
    WHERE ST_ID=V_ST_ID AND V_ST_PW=(SELECT ST_PW
                                    FROM STUDENTS
                                    WHERE ST_ID = V_ST_ID);
                                    
    SELECT ST_NAME  INTO ST_NAME_TEMP
    FROM STUDENTS
    WHERE ST_ID = V_ST_ID;
    
                                    
                                    
    IF(V_COUNT <> 1)
        THEN RAISE_APPLICATION_ERROR(-20006, '아이디 혹은 아이디를 제대로 입력해주세요');
    END IF;

    SELECT CASE WHEN D.DO_CODE IS NOT NULL THEN '중도탈락'
                ELSE 'X'
           END INTO DO_LIST_TEMP
    FROM STUDENTS S LEFT JOIN COURSE_REGISTRATIONS C 
    ON S.ST_CODE = C.ST_CODE
    LEFT JOIN DROP_OUT_LISTS D
    ON D.REG_CODE = C.REG_CODE
    WHERE S.ST_ID = V_ST_ID;
                    
    DBMS_OUTPUT.PUT_LINE('[' || ST_NAME_TEMP || ']님으로 로그인되었습니다.');
    
    IF (DO_LIST_TEMP = '중도탈락')
        THEN DBMS_OUTPUT.PUT_LINE('[' || ST_NAME_TEMP || ']님은 '  || DO_LIST_TEMP || ' 상태입니다.');  
    END IF;
END;


EXEC LOGIN_STUDENT('BON', '1566789')

EXEC LOGIN_STUDENT('MOON', '3022432')

-- 2. 성적 출력 기능 구현
-- 학생 신분으로 로그인 된 경우 자신의 수강을 이미 끝낸 과목만 출력되어야 한다.
-- 수강이 끝난 과목 선택 시 이에 대한 성적을 확인할 수 있어야 한다.
-- 출력 정보는 학생 이름, 과정명, 과목명, 교육 기간(시작일, 종료일), 교재 명, 출결, 실기, 필기, 총점, 등수가 출력되어야 한다.
-- 출력은 본인 성적 정보만 출력되어야 한다.
-- 여러 개의 과목에 대해 수강을 끝낸 경우는 통합적으로 성적 정보를 볼 수 있어야 한다.

-- VIEW 생성
CREATE OR REPLACE VIEW VIEW_STUDENTS_SCORES
AS
SELECT TT.학생명, TT.과정명, TT.과목명, TT.교육기간, TT.교재명, TT.출결, TT.실기, TT.필기, TT.총점, TT.등수, TT.아이디
FROM 
(
    SELECT T.* , T.출결 + T.실기 + T.필기 "총점" , RANK() OVER(PARTITION BY T.과목명 ORDER BY (T.출결 + T.실기 + T.필기) DESC) "등수"
    FROM 
    (
            SELECT J.SUB_NAME "과목명",CR.CRS_NAME "과정명", START_DATE || '~' || END_DATE "교육기간" , B.BK_NAME "교재명", ST.ST_NAME "학생명", S.ATTENDANCE_SCORE "출결", S.PRACTICAL_SCORE "실기", S.WRITTEN_SCORE "필기"
                ,CASE WHEN D.DO_CODE IS NOT NULL THEN '중도탈락'
                      WHEN P.END_DATE < SYSDATE THEN '수료완료'
                      WHEN P.END_DATE > SYSDATE THEN '수료중'             
                 ELSE '오류'
                 END "중도탈락여부"
                 ,ST.ST_ID "아이디"
            FROM SCORES S JOIN OPEN_SUBJECTS O
              ON S.OSUB_CODE = O.OSUB_CODE
                 JOIN SUBJECTS J
                 ON J.SUB_CODE = O.SUB_CODE
                 JOIN BOOKS B
                 ON B.BK_CODE = O.BK_CODE
                 JOIN COURSE_REGISTRATIONS C
                 ON S.REG_CODE  = C.REG_CODE
                 JOIN STUDENTS ST
                 ON ST.ST_CODE = C.ST_CODE
                 LEFT JOIN DROP_OUT_LISTS D
                 ON D.REG_CODE = C.REG_CODE
                 JOIN OPEN_COURSES P
                 ON P.OCRS_CODE = C.OCRS_CODE
                 JOIN COURSES CR
                 ON CR.CRS_CODE = P.CRS_CODE 
                
    )T
)TT;

--◎ VIEW 조회
SELECT 학생명, 과정명, 과목명, 교육기간, 교재명, 출결, 실기, 필기, 총점, 등수
FROM VIEW_STUDENTS_SCORES
WHERE 아이디 = 'MOON';

SELECT 학생명, 과정명, 과목명, 교육기간, 교재명, 출결, 실기, 필기, 총점, 등수
FROM VIEW_STUDENTS_SCORES
WHERE 아이디 = 'BON';



